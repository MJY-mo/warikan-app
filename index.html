<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WARIKAN</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#4f46e5"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WARIKAN">
    <!-- (修正) icon-180x180.png を除外 -->
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <link rel="manifest" href="manifest.json">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .shadow-soft {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
        }
        /* (追加) アコーディオン用 */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .accordion-open .accordion-content {
            max-height: 1000px; /* 十分な高さを確保 */
        }
        .accordion-open .accordion-arrow {
            transform: rotate(180deg);
        }
        
        /* (修正) 済マークのスタイルを分かりやすく変更 */
        .transaction-tile {
            /* (追加) スムーズな切り替え用 */
            transition: opacity 0.3s ease, background-color 0.3s ease;
        }
        .transaction-tile.completed::before {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 16px; /* p-4 の左パディング */
            transform: translateY(-50%);
            font-size: 2rem; /* (変更) 1.5rem -> 2rem */
            font-weight: bold;
            color: #10B981; /* green-500 */
            opacity: 1; /* (修正) 0.5 -> 1 (不透明に) */
            z-index: 10;
        }
        .transaction-tile.completed {
            background-color: #F3F4F6; /* gray-100 */
            opacity: 0.6; /* (追加) 完了したタイル全体を少し暗くする */
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <!-- (修正) 左右の余白を p-4 -> p-3 に -->
    <div class="container mx-auto max-w-lg p-3 min-h-screen flex flex-col">
        <!-- ヘッダー -->
        <header class="text-center my-6 flex items-center justify-center gap-3">
            <h1 class="text-3xl font-bold text-gray-900 tracking-wider">WARIKAN</h1>
            <button id="help-btn" class="w-8 h-8 rounded-full bg-gray-200 text-gray-600 flex items-center justify-center hover:bg-gray-300 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            </button>
            <!-- (追加) 全クリアボタン -->
            <button id="clear-all-btn" class="w-8 h-8 rounded-full bg-red-100 text-red-600 flex items-center justify-center hover:bg-red-200 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash-2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
            </button>
        </header>

        <!-- (修正) メインカードの余白を p-6 -> p-4 に -->
        <main class="bg-white p-4 rounded-2xl shadow-soft flex-grow">
            <!-- 支払いリスト -->
            <div class="mb-4">
                <!-- (修正) 見出しの文字サイズを text-lg に -->
                <label class="block text-lg font-medium text-gray-700 mb-2">1. 誰がいくら支払った？</label>
                <div id="payments-container" class="space-y-3">
                    <!-- 支払いはJSで動的に追加 -->
                </div>
                <button id="add-payment-btn" class="mt-3 w-full flex items-center justify-center gap-2 rounded-lg border border-dashed border-gray-300 p-3 text-sm font-medium text-gray-700 hover:bg-gray-100 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus-circle"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                    支払い（レシート）を追加
                </button>
            </div>

            <!-- 参加人数と割引設定 -->
            <div class="mb-4">
                <!-- (修正) 見出しの文字サイズを text-lg に -->
                <label class="block text-lg font-medium text-gray-700 mb-2">2. 何人で割る？</label>
                <div class="mb-3">
                    <label for="total-members" class="text-xs text-gray-500">合計人数</label>
                    <!-- (修正) 文字サイズを text-lg -> text-base に -->
                    <input type="number" id="total-members" min="1" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-base p-2.5" placeholder="例: 5">
                </div>
                
                <!-- (追加) 割引設定アコーディオン -->
                <div id="discount-accordion" class="border border-gray-200 rounded-lg">
                    <button id="accordion-toggle" class="flex justify-between items-center w-full p-3 bg-gray-50 hover:bg-gray-100 transition rounded-t-lg">
                        <span class="text-sm font-medium text-gray-700">割引設定（半額・免除）</span>
                        <svg class="accordion-arrow w-5 h-5 text-gray-500 transition-transform" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <div class="accordion-content">
                        <div id="discount-members-selector" class="p-3 grid grid-cols-1 gap-3">
                            <!-- 割引対象者はJSで動的に追加 -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 精算方法 -->
            <div class="mb-5">
                <!-- (修正) 見出しの文字サイズを text-lg に -->
                <label class="block text-lg font-medium text-gray-700 mb-2">3. やり取りの計算方法</label>
                <fieldset class="mt-2">
                    <div class="flex items-center space-x-6">
                        <div class="flex items-center">
                            <input id="mode-simple" name="calculation-mode" type="radio" value="simple" checked class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <!-- (修正) 文字サイズを text-sm -> text-xs に -->
                            <label for="mode-simple" class="ml-2 block text-xs text-gray-900">直接計算</label>
                        </div>
                        <div class="flex items-center">
                            <input id="mode-cash" name="calculation-mode" type="radio" value="cash" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <!-- (修正) 文字サイズを text-sm -> text-xs に -->
                            <label for="mode-cash" class="ml-2 block text-xs text-gray-900">硬貨・紙幣の枚数が最少</label>
                        </div>
                    </div>
                </fieldset>
            </div>

            <!-- 計算ボタン -->
            <!-- (修正) 文字サイズを text-lg -> text-base に -->
            <button id="calculate-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-base">
                計算する
            </button>
        </main>

        <!-- 結果表示エリア -->
        <div id="result-container" class="mt-6 hidden">
            <h2 class="text-xl font-bold text-center mb-3">計算結果</h2>
            <div id="result-card" class="bg-white p-4 rounded-2xl shadow-soft space-y-3">
                <!-- 結果はJSで動的に追加 -->
            </div>
            <div id="summary" class="mt-3 text-center text-xs text-gray-600 bg-gray-100 p-2.5 rounded-lg"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <!-- (修正) スマホで見切れないよう max-h と overflow-y-auto を追加 -->
    <div id="help-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-md w-full m-4 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-900">使い方</h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                </button>
            </div>
            <div class="text-gray-700 space-y-4">
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">操作</h4>
                    <ol class="list-decimal list-inside space-y-1 text-sm">
                        <li>「支払い（レシート）を追加」で、立て替えた人（名前も編集できます）と金額を入力します。</li>
                        <li>金額を割る合計人数を入力します。立て替えた人も含めた総人数です。</li>
                        <li>（任意）「割引設定」を開き、半額の人や全額免除の人を指定します。</li>
                        <li>やり取りの計算方法を選んで「計算する」ボタンを押してください。</li>
                        <li>計算結果のタイルをタップすると「済」マークを付けられます。この状態も自動で保存されます。</li>
                    </ol>
                </div>
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">端数の取り扱いについて</h4>
                    <p class="text-sm">割り切れない端数が出た場合、その負担者は計算方法によって自動的に最適化されます。</p>
                    <ul class="list-disc list-inside space-y-1 text-sm mt-2">
                        <li><strong>直接計算：</strong>支払いをしていない人（または支払額が少ない人）から順に1円ずつ負担します。</li>
                        <li><strong>硬貨・紙幣の枚数が最少：</strong> 全員のやり取りで、硬貨・紙幣の総移動枚数が最も少なくなる人が端数を負担します。</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">データの保存について</h4>
                    <p class="text-sm">入力内容はすべて自動でブラウザに保存されます。アプリを閉じても、計算結果や「済」マークも保持されます。</p>
                    <p class="text-sm mt-1">すべてをリセットしたい場合は、右上のゴミ箱ボタンを押してください。</p>
                </div>
            </div>
        </div>
    </div>

    <!-- (追加) 全クリア確認モーダル -->
    <div id="clear-all-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-sm w-full m-4">
            <h3 class="text-xl font-bold text-gray-900 mb-2">確認</h3>
            <p class="text-sm text-gray-700 mb-6">すべての入力内容と計算結果をリセットします。よろしいですか？</p>
            <div class="flex justify-end gap-3">
                <button id="clear-cancel-btn" type="button" class="px-4 py-2 rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 transition">キャンセル</button>
                <button id="clear-confirm-btn" type="button" class="px-4 py-2 rounded-lg bg-red-600 text-white hover:bg-red-700 transition">クリア実行</button>
            </div>
        </div>
    </div>

    <!-- 名前編集モーダル -->
    <div id="name-edit-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-sm w-full m-4">
            <h3 class="text-xl font-bold text-gray-900 mb-4">名前の編集</h3>
            <input type="text" id="name-edit-input" class="w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-base p-2.5 mb-6" placeholder="新しい名前">
            <input type="hidden" id="name-edit-old-id">
            <div class="flex justify-end gap-3">
                <button id="name-edit-cancel" type="button" class="px-4 py-2 rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 transition">キャンセル</button>
                <button id="name-edit-save" type="button" class="px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition">保存</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const paymentsContainer = document.getElementById('payments-container');
            const addPaymentBtn = document.getElementById('add-payment-btn');
            const calculateBtn = document.getElementById('calculate-btn');
            const totalMembersInput = document.getElementById('total-members');
            // (修正) 割引セレクタの親を取得
            const discountMembersSelector = document.getElementById('discount-members-selector');
            const resultContainer = document.getElementById('result-container');
            const resultCard = document.getElementById('result-card');
            const summaryDiv = document.getElementById('summary');
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const nameEditModal = document.getElementById('name-edit-modal');
            const nameEditInput = document.getElementById('name-edit-input');
            const nameEditOldId = document.getElementById('name-edit-old-id');
            const nameEditCancel = document.getElementById('name-edit-cancel');
            const nameEditSave = document.getElementById('name-edit-save');
            // (追加) アコーディオン
            const accordion = document.getElementById('discount-accordion');
            const accordionToggle = document.getElementById('accordion-toggle');
            // (追加) 全クリアボタン
            const clearAllBtn = document.getElementById('clear-all-btn');
            const clearAllModal = document.getElementById('clear-all-modal');
            const clearCancelBtn = document.getElementById('clear-cancel-btn');
            const clearConfirmBtn = document.getElementById('clear-confirm-btn');

            let paymentIdCounter = 0;
            const denominations = [10000, 5000, 1000, 500, 100, 50, 10, 5, 1];
            // (修正) 参加者リストをオブジェクト配列で管理
            let participants = []; // { id: 'uuid', name: '名前' }
            let nameEditCallback = null;
            // (追加) 計算結果と「済」状態
            let lastCalculationResult = {
                transactions: [],
                summary: {},
                completed: {} // { transactionId: true }
            };

            // (修正) データ永続化のキーとバージョン
            const STORAGE_KEY = 'warikanAppState_v4'; // v3 -> v4 (計算結果保存)

            // --- Modal Control (Help) ---
            helpBtn.addEventListener('click', () => helpModal.classList.remove('hidden'));
            closeModalBtn.addEventListener('click', () => helpModal.classList.add('hidden'));
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) helpModal.classList.add('hidden');
            });

            // --- Modal Control (Clear All) ---
            clearAllBtn.addEventListener('click', () => clearAllModal.classList.remove('hidden'));
            clearCancelBtn.addEventListener('click', () => clearAllModal.classList.add('hidden'));
            clearAllModal.addEventListener('click', (e) => {
                if (e.target === clearAllModal) clearAllModal.classList.add('hidden');
            });
            clearConfirmBtn.addEventListener('click', () => {
                console.log('All data cleared');
                localStorage.removeItem(STORAGE_KEY);
                // 状態をリセットしてリロード
                lastCalculationResult = { transactions: [], summary: {}, completed: {} };
                participants = [];
                window.location.reload();
            });


            // --- Modal Control (Name Edit) ---
            const showNameEditModal = (oldId, currentName, callback) => {
                nameEditOldId.value = oldId;
                nameEditInput.value = currentName;
                nameEditCallback = callback;
                nameEditModal.classList.remove('hidden');
                nameEditInput.focus();
                nameEditInput.select();
            };

            const hideNameEditModal = () => {
                nameEditModal.classList.add('hidden');
                nameEditCallback = null;
            };

            nameEditCancel.addEventListener('click', () => {
                // (修正) 'new_payer' でキャンセルした場合、ドロップダウンをリセット
                if (nameEditOldId.value === 'new_payer_id') {
                    document.querySelectorAll('.payer-select').forEach(select => {
                        if (select.value === 'new_payer') {
                            // 最初の参加者（例: 「自分」）に戻す
                            select.value = participants.length > 0 ? participants[0].id : '';
                        }
                    });
                }
                hideNameEditModal();
            });
            
            nameEditSave.addEventListener('click', () => {
                const newName = nameEditInput.value.trim();
                const oldId = nameEditOldId.value;
                if (newName && nameEditCallback) {
                    nameEditCallback(oldId, newName);
                }
                hideNameEditModal();
            });

            // --- Accordion Control ---
            accordionToggle.addEventListener('click', () => {
                accordion.classList.toggle('accordion-open');
                saveState(); // アコーディオンの開閉状態も保存
            });

            // --- Participant Management ---
            const createNewParticipant = (name) => {
                const id = `p_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                return { id, name };
            };

            const getParticipantName = (id) => {
                const p = participants.find(p => p.id === id);
                return p ? p.name : `不明 (${id})`;
            };

            // --- LocalStorage (Save / Load) ---
            const saveState = () => {
                try {
                    const payments = [];
                    paymentsContainer.querySelectorAll('.payment-item').forEach(item => {
                        payments.push({
                            id: item.id,
                            payerId: item.querySelector('.payer-select').value,
                            amount: item.querySelector('.amount-input').value
                        });
                    });

                    const discountSettings = {};
                    discountMembersSelector.querySelectorAll('input[type="radio"]').forEach(radio => {
                        if (radio.checked) {
                            discountSettings[radio.name] = radio.value;
                        }
                    });

                    const state = {
                        participants: participants,
                        payments: payments,
                        totalMembers: totalMembersInput.value,
                        discountSettings: discountSettings,
                        calculationMode: document.querySelector('input[name="calculation-mode"]:checked').value,
                        accordionOpen: accordion.classList.contains('accordion-open'),
                        lastCalculation: lastCalculationResult // (追加) 計算結果を保存
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                    console.log('State saved');
                } catch (e) {
                    console.error('Failed to save state:', e);
                }
            };

            const loadState = () => {
                let state;
                try {
                    const savedState = localStorage.getItem(STORAGE_KEY);
                    if (!savedState) {
                        console.log('No saved state found. Initializing.');
                        // (修正) participants にデフォルトの「自分」を追加
                        const defaultParticipant = createNewParticipant('自分');
                        participants.push(defaultParticipant);
                        addPayment(null, defaultParticipant.id); // 「自分」が選択された状態で支払い項目を追加
                        updateAllPayerDropdowns();
                        updateDiscountMemberSelector();
                        return; // 初期化終了
                    }
                    
                    state = JSON.parse(savedState);
                    console.log('State loaded:', state);

                    if (!state || !state.participants || !state.payments) {
                         throw new Error('Invalid state structure');
                    }

                } catch (e) {
                    console.error('Failed to parse state, resetting.', e);
                    localStorage.removeItem(STORAGE_KEY);
                    // (修正) participants にデフォルトの「自分」を追加
                    const defaultParticipant = createNewParticipant('自分');
                    participants.push(defaultParticipant);
                    addPayment(null, defaultParticipant.id);
                    updateAllPayerDropdowns();
                    updateDiscountMemberSelector();
                    return; // リセット終了
                }

                // 状態の復元
                participants = state.participants || [];
                
                // 参加者がいない場合は初期化
                if (participants.length === 0) {
                    const defaultParticipant = createNewParticipant('自分');
                    participants.push(defaultParticipant);
                }

                totalMembersInput.value = state.totalMembers || '';

                // 支払い項目の復元
                paymentsContainer.innerHTML = '';
                if (state.payments && state.payments.length > 0) {
                    state.payments.forEach(p => {
                        addPayment(p.id, p.payerId, p.amount);
                    });
                } else {
                     // 支払い項目が0でも、参加者がいれば最初の参加者で1つ追加
                    addPayment(null, participants[0].id);
                }

                updateAllPayerDropdowns(); // 参加者リストを先に読み込んでからドロップダウンを生成

                // 割引設定の復元
                updateDiscountMemberSelector(); // 割引セレクタを生成
                if (state.discountSettings) {
                    Object.keys(state.discountSettings).forEach(id => {
                        const selector = `input[name="${id}"][value="${state.discountSettings[id]}"]`;
                        const radio = discountMembersSelector.querySelector(selector);
                        if (radio) radio.checked = true;
                    });
                }

                // その他設定の復元
                const modeRadio = document.querySelector(`input[name="calculation-mode"][value="${state.calculationMode || 'simple'}"]`);
                if (modeRadio) modeRadio.checked = true;

                if (state.accordionOpen) {
                    accordion.classList.add('accordion-open');
                }

                // (追加) 計算結果の復元
                if (state.lastCalculation && state.lastCalculation.transactions.length > 0) {
                    lastCalculationResult = state.lastCalculation;
                    displayResults(
                        lastCalculationResult.transactions,
                        lastCalculationResult.summary.total,
                        lastCalculationResult.summary.members,
                        lastCalculationResult.summary.perPerson,
                        lastCalculationResult.summary.calcMode
                    );
                }
            };


            // --- UI Rendering ---

            const createPayerDropdown = (selectedPayerId) => {
                const select = document.createElement('select');
                // (修正) 文字サイズを text-base -> text-sm に
                select.className = 'payer-select w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2.5 text-sm';
                
                participants.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p.id;
                    option.textContent = p.name; // (修正) getParticipantName -> p.name
                    if (p.id === selectedPayerId) option.selected = true;
                    select.appendChild(option);
                });

                const newOption = document.createElement('option');
                newOption.value = 'new_payer';
                newOption.textContent = '新しい支払い者を追加...';
                select.appendChild(newOption);
                return select;
            };

            const updateAllPayerDropdowns = () => {
                const allSelects = document.querySelectorAll('.payer-select');
                allSelects.forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = ''; 
                    
                    participants.forEach(p => {
                        const option = document.createElement('option');
                        option.value = p.id;
                        option.textContent = p.name; // (修正) getParticipantName -> p.name
                        select.appendChild(option);
                    });
                    const newOption = document.createElement('option');
                    newOption.value = 'new_payer';
                    newOption.textContent = '新しい支払い者を追加...';
                    select.appendChild(newOption);

                    // 参加者リストにIDが存在するか確認
                    if (participants.some(p => p.id === currentValue)) {
                        select.value = currentValue;
                    } else if (participants.length > 0) {
                        select.value = participants[0].id;
                    }
                });
            };

            const updateDiscountMemberSelector = () => {
                // (修正) 参加者リストのロジックを修正
                const totalMembers = parseInt(totalMembersInput.value) || 0;
                const currentPayerIds = new Set(participants.filter(p => p.name !== '参加者').map(p => p.id));
                
                // 支払い者リストと「参加者X」リストを同期
                const currentParticipantIds = new Set(participants.map(p => p.id));
                
                // 1. 支払者でない「参加者X」を一度リストから除く
                participants = participants.filter(p => !p.name.startsWith('参加者'));

                // 2. 支払者リストを更新
                document.querySelectorAll('.payer-select').forEach(select => {
                    if(select.value !== 'new_payer') {
                        currentPayerIds.add(select.value);
                    }
                });
                
                // 3. 支払者リストにいるが、participants にいない人を追加 (名前編集などで発生)
                currentPayerIds.forEach(id => {
                    if (!participants.some(p => p.id === id)) {
                         // このIDはもはや存在しないか、不正
                         console.warn(`Payer ID ${id} not found in participants list.`);
                    }
                });

                // 4. 「参加者X」を追加
                const nonPayerCount = totalMembers - participants.length;
                if (nonPayerCount > 0) {
                    for (let i = 1; i <= nonPayerCount; i++) {
                        // (修正) 既存の「参加者X」を探すのではなく、新しく作る
                        const newP = createNewParticipant(`参加者${i}`);
                        participants.push(newP);
                    }
                } else if (nonPayerCount < 0) {
                    // 人数が減った場合、末尾の「参加者X」から削除
                    let removeCount = Math.abs(nonPayerCount);
                    participants = participants.filter(p => {
                        if (p.name.startsWith('参加者') && removeCount > 0) {
                            removeCount--;
                            return false; // 削除
                        }
                        return true;
                    });
                }
                
                // 5. 参加者名でソート
                participants.sort((a, b) => a.name.localeCompare(b.name, 'ja'));

                // --- 描画処理 ---
                const selector = discountMembersSelector;
                
                // (修正) 以前のチェック状態を保持
                const previousSettings = {};
                selector.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                    previousSettings[radio.name] = radio.value;
                });
                
                selector.innerHTML = ''; // 描画内容をクリア

                if (participants.length === 0) {
                    selector.innerHTML = '<p class="text-xs text-gray-500">参加者がいません。</p>';
                    return;
                }

                participants.forEach(p => {
                    const participantId = p.id;
                    const participantName = p.name;
                    const radioName = `discount-${participantId}`;
                    // (修正) 以前のチェック状態を取得
                    const checkedValue = previousSettings[radioName] || 'full';

                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between p-2.5 bg-gray-100 rounded-md';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `discount-full-${participantId}`;
                    label.className = 'text-sm text-gray-700 cursor-pointer';
                    label.textContent = participantName;
                    
                    const radioGroup = document.createElement('div');
                    radioGroup.className = 'flex items-center gap-3';
                    
                    // (修正) 全額(通常)・半額・免除の3択
                    radioGroup.innerHTML = `
                        <div class="flex items-center">
                            <input type="radio" id="discount-full-${participantId}" name="${radioName}" value="full" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${checkedValue === 'full' ? 'checked' : ''}>
                            <label for="discount-full-${participantId}" class="ml-1.5 text-xs text-gray-600">通常</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="discount-half-${participantId}" name="${radioName}" value="half" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${checkedValue === 'half' ? 'checked' : ''}>
                            <label for="discount-half-${participantId}" class="ml-1.5 text-xs text-gray-600">半額</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="discount-exempt-${participantId}" name="${radioName}" value="exempt" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${checkedValue === 'exempt' ? 'checked' : ''}>
                            <label for="discount-exempt-${participantId}" class="ml-1.5 text-xs text-gray-600">免除</label>
                        </div>
                    `;
                    
                    div.appendChild(label);
                    div.appendChild(radioGroup);
                    selector.appendChild(div);

                    // ラジオボタンに変更があったら保存
                    radioGroup.querySelectorAll('input[type="radio"]').forEach(radio => {
                        radio.addEventListener('change', saveState);
                    });
                });
            };

            const addPayment = (id = null, selectedPayerId = null, amount = '') => {
                paymentIdCounter++;
                const paymentId = id || `payment-${paymentIdCounter}`;

                const paymentEl = document.createElement('div');
                paymentEl.className = 'payment-item flex items-center gap-2'; // (修正) gap-3 -> gap-2
                paymentEl.id = paymentId;
                
                // (修正) selectedPayerId が null なら participants[0].id を使う
                const payerId = selectedPayerId || (participants.length > 0 ? participants[0].id : null);
                const selectEl = createPayerDropdown(payerId);

                // (修正) レイアウト変更 (金額幅固定、名前flex-grow)
                paymentEl.innerHTML = `
                    <div class="flex-grow">
                        ${selectEl.outerHTML}
                    </div>
                    <button type="button" class="edit-payer-btn flex-shrink-0 text-gray-400 hover:text-indigo-500 transition p-1">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-3"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
                    </button>
                    <div class="w-28 flex-shrink-0"> <!-- (修正) w-2/5 -> w-28 -->
                        <input type="number" class="amount-input w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2.5 text-base" placeholder="金額 (円)" value="${amount}">
                    </div>
                    <button type="button" class="remove-payment-btn flex-shrink-0 text-gray-400 hover:text-red-500 transition p-1" data-remove="${paymentId}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                    </button>
                `;
                paymentsContainer.appendChild(paymentEl);

                const payerSelect = paymentEl.querySelector('.payer-select');
                
                payerSelect.addEventListener('change', (e) => {
                    if (e.target.value === 'new_payer') {
                        // 新しい支払い者を追加
                        // (修正) 'new_payer_id' を渡す
                        showNameEditModal('new_payer_id', '', (oldId, newName) => {
                            const newP = createNewParticipant(newName);
                            participants.push(newP);
                            // (修正) 合計人数入力欄も更新する
                            totalMembersInput.value = participants.length;
                            // ドロップダウンを更新
                            updateAllPayerDropdowns();
                            // 割引リストも更新
                            updateDiscountMemberSelector();
                            // (修正) e.target.value -> payerSelect.value に変更 (より安全な参照)
                            payerSelect.value = newP.id;
                            saveState();
                        });
                    } else {
                         saveState(); // 既存の支払い者を選んだ場合も保存
                    }
                });
                
                // (追加) 支払い者リスト横の編集ボタン
                paymentEl.querySelector('.edit-payer-btn').addEventListener('click', () => {
                    const currentId = payerSelect.value;
                    const currentName = getParticipantName(currentId);
                    showNameEditModal(currentId, currentName, (oldId, newName) => {
                        const p = participants.find(p => p.id === oldId);
                        if (p) {
                            p.name = newName;
                            updateAllPayerDropdowns();
                            updateDiscountMemberSelector();
                            saveState();
                        }
                    });
                });

                paymentEl.querySelector('.remove-payment-btn').addEventListener('click', (e) => {
                    if (paymentsContainer.querySelectorAll('.payment-item').length > 1) {
                        const idToRemove = e.currentTarget.getAttribute('data-remove');
                        document.getElementById(idToRemove).remove();
                        saveState();
                    } else {
                        // 最後の1つは金額だけクリア
                        paymentEl.querySelector('.amount-input').value = '';
                        saveState();
                    }
                });
                
                // 金額変更時も保存
                paymentEl.querySelector('.amount-input').addEventListener('input', saveState);
            };
            
            addPaymentBtn.addEventListener('click', () => {
                // (修正) 最後の支払い者のIDを引き継いで追加
                const lastPayerId = paymentsContainer.querySelector('.payment-item:last-child .payer-select')?.value || participants[0].id;
                addPayment(null, lastPayerId);
                saveState();
            });
            totalMembersInput.addEventListener('input', () => {
                updateDiscountMemberSelector();
                updateAllPayerDropdowns(); // 参加者Xの名前が変わるため
                saveState();
            });
            
            // --- Calculation Logic (変更なし) ---
            
            const getBreakdown = (value) => {
                let remaining = value;
                const breakdown = [];
                for (const denom of denominations) {
                    if (remaining >= denom) {
                        const numPieces = Math.floor(remaining / denom);
                        if (numPieces > 0) breakdown.push({denom, count: numPieces});
                        remaining %= denom;
                    }
                }
                return breakdown;
            };

            const countPiecesFromBreakdown = (breakdown) => {
                return breakdown.reduce((sum, item) => sum + item.count, 0);
            };

             const getOptimalPayment = (amount) => {
                const directBreakdown = getBreakdown(amount);
                let bestOption = {
                    count: countPiecesFromBreakdown(directBreakdown),
                    payment: amount,
                    change: 0
                };

                const candidates = new Set();
                if (amount > 0) {
                    if (amount % 100 !== 0) candidates.add(Math.ceil(amount / 100) * 100);
                    if (amount % 500 !== 0) candidates.add(Math.ceil(amount / 500) * 500);
                    if (amount % 1000 !== 0) candidates.add(Math.ceil(amount / 1000) * 1000);
                    
                    const nextThousand = Math.ceil(amount/1000) * 1000;
                    if(nextThousand < 10000 && nextThousand > 0) candidates.add(nextThousand + 1000);

                    denominations.forEach(d => {
                        if (d > amount) candidates.add(d);
                    });
                }
                
                candidates.forEach(candidateAmount => {
                    if(candidateAmount <= amount) return;

                    const paymentBreakdown = getBreakdown(candidateAmount);
                    const paymentCount = countPiecesFromBreakdown(paymentBreakdown);

                    const changeAmount = candidateAmount - amount;
                    const changeBreakdown = getBreakdown(changeAmount);
                    const changeCount = countPiecesFromBreakdown(changeBreakdown);

                    const totalCount = paymentCount + changeCount;

                    if (totalCount < bestOption.count) {
                        bestOption = {
                            count: totalCount,
                            payment: candidateAmount,
                            change: changeAmount
                        };
                    }
                });
                 
                let text;
                if (bestOption.change > 0) {
                     text = `【お釣り】 ${bestOption.payment.toLocaleString()}円で払い、${bestOption.change.toLocaleString()}円のお釣りをもらう`
                } else {
                     text = `【直接払い】 ${bestOption.payment.toLocaleString()}円を支払う`
                }
                return { count: bestOption.count, text };
            };
            
            const calculateDirectSettlementCost = (balances) => {
                let cost = 0;
                const tempBalances = new Map(balances);
                const creditors = [];
                const debtors = [];
                tempBalances.forEach((amount, personId) => {
                    if(amount > 0.5) creditors.push({personId, amount: Math.round(amount)});
                    else if (amount < -0.5) debtors.push({personId, amount: -Math.round(amount)});
                });
                
                creditors.sort((a,b) => b.amount - a.amount);
                debtors.sort((a,b) => b.amount - a.amount);

                let c = 0, d = 0;
                while(c < creditors.length && d < debtors.length){
                    const transfer = Math.min(creditors[c].amount, debtors[d].amount);
                    cost += getOptimalPayment(transfer).count;
                    creditors[c].amount -= transfer;
                    debtors[d].amount -= transfer;
                    if(creditors[c].amount < 0.5) c++;
                    if(debtors[d].amount < 0.5) d++;
                }
                return cost;
            };

            const solveCashMinimization = (initialBalances) => {
                let transactions = [];
                const tempBalances = new Map(initialBalances);

                while (true) {
                    const currentCost = calculateDirectSettlementCost(tempBalances);
                    let bestReduction = 0;
                    let bestMove = null;

                    const debtors = [];
                    tempBalances.forEach((amount, personId) => {
                       if (amount < -0.5) debtors.push(personId);
                    });
                    
                    const participantIds = Array.from(tempBalances.keys());

                    for (const from of debtors) {
                        for (const to of participantIds) {
                            if (from === to) continue;

                            const hypotheticalBalances = new Map(tempBalances);
                            const amountToPay = -Math.round(hypotheticalBalances.get(from));
                            
                            hypotheticalBalances.set(from, hypotheticalBalances.get(from) + amountToPay);
                            hypotheticalBalances.set(to, hypotheticalBalances.get(to) - amountToPay);

                            const newCost = calculateDirectSettlementCost(hypotheticalBalances);
                            const moveCost = getOptimalPayment(amountToPay).count;
                            const totalNewCost = moveCost + newCost;
                            
                            const reduction = currentCost - totalNewCost;

                            if (reduction > bestReduction) {
                                bestReduction = reduction;
                                bestMove = { from, to, amount: amountToPay };
                            }
                        }
                    }

                    if (bestMove) {
                        transactions.push(bestMove);
                        const { from, to, amount } = bestMove;
                        tempBalances.set(from, tempBalances.get(from) + amount);
                        tempBalances.set(to, tempBalances.get(to) - amount);
                    } else {
                        const finalCreditors = [], finalDebtors = [];
                        tempBalances.forEach((amount, personId) => {
                            if (amount > 0.5) finalCreditors.push({ personId, amount: Math.round(amount) });
                            else if (amount < -0.5) finalDebtors.push({ personId, amount: -Math.round(amount) });
                        });
                         finalCreditors.sort((a, b) => b.amount - a.amount);
                        finalDebtors.sort((a, b) => b.amount - a.amount);

                        let c = 0, d = 0;
                        while(c < finalCreditors.length && d < finalDebtors.length){
                            const transfer = Math.min(finalCreditors[c].amount, finalDebtors[d].amount);
                            transactions.push({ from: finalDebtors[d].personId, to: finalCreditors[c].personId, amount: transfer });
                            finalCreditors[c].amount -= transfer;
                            finalDebtors[d].amount -= transfer;
                            if(finalCreditors[c].amount < 0.5) c++;
                            if(finalDebtors[d].amount < 0.5) d++;
                        }
                        break;
                    }
                }
                
                let totalCoinCost = 0;
                transactions.forEach(t => {
                    totalCoinCost += getOptimalPayment(t.amount).count;
                });

                return { transactions, totalCoinCost };
            };
            
            // --- Calculation Trigger ---

            calculateBtn.addEventListener('click', () => {
                // (修正) try...catch で計算全体を囲む
                try {
                    const totalMembers = parseInt(totalMembersInput.value);
                    
                    if (isNaN(totalMembers) || totalMembers <= 0) {
                        showError('合計人数を正しく入力してください。');
                        return;
                    }
                    
                    // (修正) 参加者リストが人数と合っているか最終確認
                    if (participants.length !== totalMembers) {
                        console.warn(`Participant count (${participants.length}) mismatch with total members (${totalMembers}). Re-syncing.`);
                        updateDiscountMemberSelector();
                        updateAllPayerDropdowns();
                        // 再度チェック
                        if (participants.length !== totalMembers) {
                             showError('参加者リストの更新に失敗しました。ページをリロードしてください。');
                             return;
                        }
                    }

                    const paymentItems = paymentsContainer.querySelectorAll('.payment-item');
                    const aggregatedPayments = new Map();
                    let totalPayment = 0;

                    paymentItems.forEach(item => {
                        const payerId = item.querySelector('.payer-select').value;
                        const amount = parseFloat(item.querySelector('.amount-input').value);
                        if (payerId !== 'new_payer' && !isNaN(amount) && amount > 0) {
                            aggregatedPayments.set(payerId, (aggregatedPayments.get(payerId) || 0) + amount);
                            totalPayment += amount;
                        }
                    });

                    if (totalPayment <= 0) {
                        showError('支払いを1つ以上入力してください。');
                        return;
                    }
                    
                    // (修正) 割引設定の取得
                    const discountSettings = {};
                    discountMembersSelector.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                        // radio.name は 'discount-p_1729...'
                        const participantId = radio.name.replace('discount-', '');
                        discountSettings[participantId] = radio.value; // 'full', 'half', 'exempt'
                    });

                    let totalUnits = 0;
                    participants.forEach(p => {
                        const setting = discountSettings[p.id] || 'full';
                        if (setting === 'half') {
                            totalUnits += 0.5;
                        } else if (setting === 'full') {
                            totalUnits += 1.0;
                        }
                        // 'exempt' (免除) の場合は 0 を加算
                    });
                    
                    if (totalUnits <= 0) {
                        showError('割り勘の対象者がいません（全員免除など）。');
                        return;
                    }
                    
                    const payments = Array.from(aggregatedPayments, ([payerId, amount]) => ({ payerId, amount }));
                    
                    // 1単位あたりのコスト (端数切り捨て)
                    const baseUnitCost = Math.floor(totalPayment / totalUnits);
                    
                    const memberCosts = new Map();
                    let calculatedTotal = 0;

                    participants.forEach(p => {
                        const setting = discountSettings[p.id] || 'full';
                        let cost = 0;
                        if (setting === 'half') {
                            cost = Math.floor(baseUnitCost * 0.5);
                        } else if (setting === 'full') {
                            cost = baseUnitCost;
                        }
                        memberCosts.set(p.id, cost);
                        calculatedTotal += cost;
                    });
                    
                    let remainder = totalPayment - calculatedTotal;

                    const calcMode = document.querySelector('input[name="calculation-mode"]:checked').value;
                    
                    // (修正) 端数処理の対象者決定ロジック
                    // 支払いをしていない人、または支払額が負担額より少ない人を優先
                    const tempBalances = new Map();
                    memberCosts.forEach((cost, id) => { tempBalances.set(id, -cost); });
                    payments.forEach(p => { tempBalances.set(p.payerId, (tempBalances.get(p.payerId) || 0) + p.amount); });

                    if (remainder > 0) {
                        if (calcMode === 'cash') {
                            // --- 硬貨最少モードの端数処理 ---
                            for (let i = 0; i < remainder; i++) {
                                let bestPersonId = null;
                                let minCost = Infinity;

                                for (const p of participants) {
                                    const participantId = p.id;
                                    // 免除の人は端数負担しない
                                    if ((discountSettings[participantId] || 'full') === 'exempt') continue;

                                    const hypotheticalCosts = new Map(memberCosts);
                                    hypotheticalCosts.set(participantId, hypotheticalCosts.get(participantId) + 1);

                                    const hypotheticalBalances = new Map();
                                    hypotheticalCosts.forEach((cost, id) => { hypotheticalBalances.set(id, -cost); });
                                    payments.forEach(p => { hypotheticalBalances.set(p.payerId, (hypotheticalBalances.get(p.payerId) || 0) + p.amount); });
                                    
                                    const { totalCoinCost } = solveCashMinimization(hypotheticalBalances);

                                    if (totalCoinCost < minCost) {
                                        minCost = totalCoinCost;
                                        bestPersonId = participantId;
                                    }
                                }
                                if(bestPersonId) {
                                    memberCosts.set(bestPersonId, memberCosts.get(bestPersonId) + 1);
                                } else {
                                    // 免除以外全員試してもダメだった場合 (通常ありえないが)
                                    const firstNonExempt = participants.find(p => (discountSettings[p.id] || 'full') !== 'exempt');
                                    if (firstNonExempt) {
                                        memberCosts.set(firstNonExempt.id, memberCosts.get(firstNonExempt.id) + 1);
                                    }
                                }
                            }
                        } else {
                            // --- 直接計算モードの端数処理 ---
                            let remainderTargets = [];
                            
                            // 1. 支払いがマイナスの人（借りてる人）
                            const debtors = participants.filter(p => (tempBalances.get(p.id) || 0) < 0 && (discountSettings[p.id] || 'full') !== 'exempt');
                            // 2. 支払いが0の人
                            const nonPayers = participants.filter(p => (tempBalances.get(p.id) || 0) === 0 && (discountSettings[p.id] || 'full') !== 'exempt');
                            
                            // 借りてる人 > 支払0の人 > 全員 の順で優先
                            if (debtors.length > 0) {
                                remainderTargets = debtors.sort((a,b) => (tempBalances.get(a.id) || 0) - (tempBalances.get(b.id) || 0)).map(p => p.id);
                            } else if (nonPayers.length > 0) {
                                remainderTargets = nonPayers.map(p => p.id);
                            } else {
                                // 全員が支払いプラス（貸してる）場合、全員で負担
                                 remainderTargets = participants.filter(p => (discountSettings[p.id] || 'full') !== 'exempt').map(p => p.id);
                            }
                            
                            if(remainderTargets.length === 0) {
                                 // 全員免除の場合
                                 console.error("No one to assign remainder to.");
                            } else {
                                for (let i = 0; i < remainder; i++) {
                                    const targetPersonId = remainderTargets[i % remainderTargets.length];
                                    memberCosts.set(targetPersonId, memberCosts.get(targetPersonId) + 1);
                                }
                            }
                        }
                    }

                    // --- 最終的な精算 ---
                    const finalBalances = new Map();
                    memberCosts.forEach((cost, id) => { finalBalances.set(id, -cost); });
                    payments.forEach(p => { finalBalances.set(p.payerId, (finalBalances.get(p.payerId) || 0) + p.amount); });
                    
                    let transactions = [];
                    if (calcMode === 'cash') {
                        transactions = solveCashMinimization(finalBalances).transactions;
                    } else {
                         const creditors = [], debtors = [];
                        finalBalances.forEach((amount, personId) => {
                            if (amount > 0.5) creditors.push({ personId, amount });
                            else if (amount < -0.5) debtors.push({ personId, amount: -amount });
                        });
                        creditors.sort((a,b) => b.amount - a.amount);
                        debtors.sort((a,b) => b.amount - a.amount);
                        let c = 0, d = 0;
                        while(c < creditors.length && d < debtors.length){
                            const transfer = Math.min(creditors[c].amount, debtors[d].amount);
                            if (transfer > 0.5) transactions.push({from: debtors[d].personId, to: creditors[c].personId, amount: Math.round(transfer)});
                            creditors[c].amount -= transfer;
                            debtors[d].amount -= transfer;
                            if(creditors[c].amount < 0.5) c++;
                            if(debtors[d].amount < 0.5) d++;
                        }
                    }
                    
                    // (追加) トランザクションIDを付与
                    transactions = transactions.map((t, index) => ({
                        ...t,
                        id: `tx_${index}_${t.from}_${t.to}`
                    }));

                    const displayFullCost = totalUnits > 0 ? Math.round(totalPayment / totalUnits) : 0;

                    // (追加) 計算結果を保存
                    lastCalculationResult = {
                        transactions: transactions,
                        summary: {
                            total: totalPayment,
                            members: totalMembers,
                            perPerson: displayFullCost,
                            calcMode: calcMode
                        },
                        completed: {} // 新しい計算なので「済」マークはリセット
                    };

                    displayResults(transactions, totalPayment, totalMembers, displayFullCost, calcMode);
                    saveState();
                
                } catch (e) {
                    // (追加) 予期しないエラーをキャッチ
                    console.error('Calculation failed:', e);
                    showError(`計算中にエラーが発生しました。入力内容を見直すか、リセットをお試しください。(エラー: ${e.message})`);
                }
            });
            
            const displayResults = (transactions, total, members, perPerson, calcMode) => {
                resultCard.innerHTML = '';
                const colorPalette = [
                    '#DBEAFE', '#D1FAE5', '#FEF3C7', '#E9D5FF',
                    '#FCE7F3', '#FEE2E2', '#E0E7FF', '#FEF9C3'
                ];
                const colorMap = new Map();
                participants.forEach((p, index) => {
                    colorMap.set(p.id, colorPalette[index % colorPalette.length]);
                });
                
                transactions.sort((a, b) => {
                    const nameA = getParticipantName(a.from);
                    const nameB = getParticipantName(b.from);
                    const rankA = nameA.startsWith('参加者') ? 1 : 0;
                    const rankB = nameB.startsWith('参加者') ? 1 : 0;
                    if (rankA !== rankB) return rankA - rankB;
                    return nameA.localeCompare(nameB, 'ja');
                });

                if (transactions.length === 0) {
                    resultCard.innerHTML = `<p class="text-center text-gray-600">精算の必要はありません。</p>`;
                } else {
                    transactions.forEach((t) => {
                        const fromColor = colorMap.get(t.from) || '#F3F4F6';
                        const toColor = colorMap.get(t.to) || '#F3F4F6';
                        
                        const resultEl = document.createElement('div');
                        // (追加) 済マークとタップイベント用のクラスとID
                        resultEl.className = `transaction-tile p-4 rounded-lg fade-in relative cursor-pointer`;
                        resultEl.id = t.id;
                        if (lastCalculationResult.completed[t.id]) {
                             resultEl.classList.add('completed');
                        }
                        resultEl.style.background = `linear-gradient(to right, ${fromColor} 0%, #FFFFFF 50%, ${toColor} 100%)`;

                        const mainInfo = `
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-2">
                                    <span class="font-bold text-gray-800 text-sm">${getParticipantName(t.from)}</span>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-500"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                                    <span class="font-bold text-gray-800 text-sm">${getParticipantName(t.to)}</span>
                                </div>
                                <span class="font-bold text-base text-indigo-700">¥${t.amount.toLocaleString()}</span>
                            </div>
                        `;

                        let paymentDetail = '';
                        if (calcMode === 'cash') {
                            const payment = getOptimalPayment(t.amount);
                            paymentDetail = `
                                <div class="mt-2 pt-2 border-t border-gray-400 border-opacity-30">
                                    <p class="text-xs font-medium text-gray-800">支払い方法提案:</p>
                                    <p class="text-xs text-gray-600">${payment.text}</p>
                                </div>
                            `;
                        }

                        resultEl.innerHTML = mainInfo + paymentDetail;
                        resultCard.appendChild(resultEl);

                        // (追加) 済マークのトグルイベント
                        resultEl.addEventListener('click', () => {
                            const txId = resultEl.id;
                            if (lastCalculationResult.completed[txId]) {
                                delete lastCalculationResult.completed[txId];
                                resultEl.classList.remove('completed');
                            } else {
                                lastCalculationResult.completed[txId] = true;
                                resultEl.classList.add('completed');
                            }
                            saveState(); // 済の状態を保存
                        });
                    });
                }
                
                summaryDiv.innerHTML = `
                    <strong>合計:</strong> ¥${total.toLocaleString()} / 
                    <strong>人数:</strong> ${members}人 / 
                    <strong>目安:</strong> 約¥${perPerson.toLocaleString()}
                `;

                resultContainer.classList.remove('hidden');
                resultContainer.scrollIntoView({ behavior: 'smooth' });
            };

            const showError = (message) => {
                resultContainer.classList.remove('hidden');
                summaryDiv.innerHTML = '';
                resultCard.innerHTML = `<p class="text-center text-red-600 font-semibold p-4">${message}</p>`;
                resultContainer.scrollIntoView({ behavior: 'smooth' });
            };
            
            // --- PWA Registration ---
            // ( sw.js と manifest.json を外部ファイル化したため、動的生成ロジックは削除 )
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js') // (修正) 外部ファイルを登録
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            }

            // --- 初期化 ---
            // (修正) 計算モードのラジオボタンにも保存イベントを追加
            document.querySelectorAll('input[name="calculation-mode"]').forEach(radio => {
                radio.addEventListener('change', saveState);
            });
            
            loadState(); // ページの読み込み時に状態を復元
        });
    </script>
</body>
</html>

