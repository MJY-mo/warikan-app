<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WARIKAN</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#4f46e5"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WARIKAN">
    <link rel="apple-touch-icon" href="icon-192x192.png"> 
    <link rel="manifest" href="manifest.json">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .shadow-soft {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <div class="container mx-auto max-w-lg p-4 min-h-screen flex flex-col">
        <!-- ヘッダー -->
        <header class="text-center my-8 flex items-center justify-center gap-3">
            <h1 class="text-4xl font-bold text-gray-900 tracking-wider">WARIKAN</h1>
            <button id="help-btn" class="w-8 h-8 rounded-full bg-gray-200 text-gray-600 flex items-center justify-center hover:bg-gray-300 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            </button>
        </header>

        <main class="bg-white p-6 rounded-2xl shadow-soft flex-grow">
            <!-- 支払いリスト -->
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">1. 誰がいくら支払った？</label>
                <div id="payments-container" class="space-y-3">
                    <!-- 支払いはJSで動的に追加 -->
                </div>
                <button id="add-payment-btn" class="mt-4 w-full flex items-center justify-center gap-2 rounded-lg border border-dashed border-gray-300 p-3 text-sm font-medium text-gray-700 hover:bg-gray-100 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus-circle"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                    支払い（レシート）を追加
                </button>
            </div>

            <!-- 参加人数と半額設定 -->
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">2. 何人で割る？</label>
                <div class="mb-4">
                    <label for="total-members" class="text-xs text-gray-500">合計人数</label>
                    <input type="number" id="total-members" min="1" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-lg p-3" placeholder="例: 5">
                </div>
                <div>
                    <label class="text-xs text-gray-500">半額払いの人を選択</label>
                    <div id="half-members-selector" class="mt-2 grid grid-cols-2 sm:grid-cols-3 gap-2">
                        <!-- 半額対象者はJSで動的に追加 -->
                    </div>
                </div>
            </div>
            
            <!-- 精算方法 -->
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">3. やり取りの計算方法</label>
                <fieldset class="mt-2">
                    <div class="flex items-center space-x-6">
                        <div class="flex items-center">
                            <input id="mode-simple" name="calculation-mode" type="radio" value="simple" checked class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <label for="mode-simple" class="ml-2 block text-sm text-gray-900">直接計算</label>
                        </div>
                        <div class="flex items-center">
                            <input id="mode-cash" name="calculation-mode" type="radio" value="cash" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <label for="mode-cash" class="ml-2 block text-sm text-gray-900">硬貨・紙幣の枚数が最少</label>
                        </div>
                    </div>
                </fieldset>
            </div>

            <!-- 計算ボタン -->
            <button id="calculate-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-lg">
                計算する
            </button>
        </main>

        <!-- 結果表示エリア -->
        <div id="result-container" class="mt-8 hidden">
            <h2 class="text-2xl font-bold text-center mb-4">計算結果</h2>
            <div id="result-card" class="bg-white p-6 rounded-2xl shadow-soft space-y-3">
                <!-- 結果はJSで動的に追加 -->
            </div>
            <div id="summary" class="mt-4 text-center text-sm text-gray-600 bg-gray-100 p-3 rounded-lg"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-md w-full m-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-900">操作</h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                </button>
            </div>
            <div class="text-gray-700 space-y-4">
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">操作</h4>
                    <ol class="list-decimal list-inside space-y-1 text-sm">
                        <li>「自分」の支払額を入力します。別の人が払った場合は「支払い（レシート）を追加」します。</li>
                        <li>「新しい支払い者...」を選ぶか、名前の横の鉛筆ボタンで名前を編集できます。</li>
                        <li>金額を割る合計人数を入力します。立て替えた人も含めた総人数です。半額の人を選びたい場合は対象者を選びます。</li>
                        <li>やり取りの計算方法を選んで計算するボタンを押してください。</li>
                    </ol>
                </div>
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">端数の取り扱いについて</h4>
                    <p class="text-sm">割り切れない端数が出た場合、その負担者は計算方法によって自動的に最適化されます。</p>
                    <ul class="list-disc list-inside space-y-1 text-sm mt-2">
                        <li><strong>直接計算：</strong>支払いをしていない人（または支払額が少ない人）から順に1円ずつ負担します。</li>
                        <li><strong>硬貨・紙幣の枚数が最少：</strong> 全員のやり取りで、硬貨・紙幣の総移動枚数が最も少なくなる人が端数を負担します。</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Name Edit Modal -->
    <div id="name-edit-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-sm w-full m-4">
            <h3 id="name-edit-title" class="text-xl font-bold text-gray-900 mb-4">名前を編集</h3>
            <div class="text-gray-700 space-y-4">
                <input type="text" id="name-edit-input" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-lg p-3" placeholder="例: 田中">
                <input type="hidden" id="name-edit-old-name">
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="name-edit-cancel-btn" class="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors">
                    キャンセル
                </button>
                <button id="name-edit-save-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition-colors">
                    保存
                </button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element Cache ---
            const paymentsContainer = document.getElementById('payments-container');
            const addPaymentBtn = document.getElementById('add-payment-btn');
            const calculateBtn = document.getElementById('calculate-btn');
            const totalMembersInput = document.getElementById('total-members');
            const halfMembersSelector = document.getElementById('half-members-selector');
            const resultContainer = document.getElementById('result-container');
            const resultCard = document.getElementById('result-card');
            const summaryDiv = document.getElementById('summary');
            
            // --- Modals ---
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const nameEditModal = document.getElementById('name-edit-modal');
            const nameEditTitle = document.getElementById('name-edit-title');
            const nameEditInput = document.getElementById('name-edit-input');
            const nameEditOldName = document.getElementById('name-edit-old-name');
            const nameEditSaveBtn = document.getElementById('name-edit-save-btn');
            const nameEditCancelBtn = document.getElementById('name-edit-cancel-btn');

            // --- State ---
            let participantNames = new Map([['A', '自分']]); // { 'A': '自分', 'B': '田中' }
            let paymentIdCounter = 0;
            const denominations = [10000, 5000, 1000, 500, 100, 50, 10, 5, 1];
            const STORAGE_KEY = 'warikanAppState_v2';
            let activeNameEditCallback = null;

            // --- Modal Control ---
            helpBtn.addEventListener('click', () => helpModal.classList.remove('hidden'));
            closeModalBtn.addEventListener('click', () => helpModal.classList.add('hidden'));
            helpModal.addEventListener('click', (e) => {
                if(e.target === helpModal) helpModal.classList.add('hidden');
            });

            const showNameEditModal = (oldInternalName, currentDisplayName, title, callback) => {
                nameEditTitle.textContent = title;
                nameEditInput.value = (currentDisplayName === oldInternalName || currentDisplayName.startsWith('参加者')) ? '' : currentDisplayName;
                nameEditInput.placeholder = (currentDisplayName.startsWith('参加者') ? '例: 田中' : currentDisplayName);
                nameEditOldName.value = oldInternalName;
                activeNameEditCallback = callback;
                nameEditModal.classList.remove('hidden');
                nameEditInput.focus();
            };

            const hideNameEditModal = () => {
                nameEditModal.classList.add('hidden');
                activeNameEditCallback = null;
            };

            nameEditSaveBtn.addEventListener('click', () => {
                const oldInternalName = nameEditOldName.value;
                const newDisplayName = nameEditInput.value.trim();
                
                if (newDisplayName && activeNameEditCallback) {
                    activeNameEditCallback(oldInternalName, newDisplayName);
                }
                hideNameEditModal();
            });
            nameEditCancelBtn.addEventListener('click', hideNameEditModal);
            nameEditModal.addEventListener('click', (e) => {
                if(e.target === nameEditModal) hideNameEditModal();
            });

            // --- Storage ---
            const saveState = () => {
                try {
                    const payments = [];
                    paymentsContainer.querySelectorAll('.payment-item').forEach(item => {
                        const payer = item.querySelector('.payer-select').value;
                        const amount = item.querySelector('.amount-input').value;
                        payments.push({ id: item.id, payer, amount });
                    });

                    const halfChecked = Array.from(halfMembersSelector.querySelectorAll('input:checked')).map(cb => cb.value);

                    const state = {
                        participantNames: Array.from(participantNames.entries()),
                        payments,
                        totalMembers: totalMembersInput.value,
                        halfChecked,
                        calcMode: document.querySelector('input[name="calculation-mode"]:checked').value
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                } catch (e) {
                    console.error("Failed to save state to localStorage", e);
                }
            };

            const loadState = () => {
                try {
                    const savedState = localStorage.getItem(STORAGE_KEY);
                    if (!savedState) {
                        addPayment(); // 初回起動時
                        return;
                    }
                    
                    const state = JSON.parse(savedState);

                    if (state.participantNames) {
                        participantNames = new Map(state.participantNames);
                    }
                    
                    paymentsContainer.innerHTML = '';
                    if (state.payments && state.payments.length > 0) {
                        state.payments.forEach(p => {
                            addPayment(p.payer, p.amount, p.id);
                        });
                        paymentIdCounter = state.payments.length;
                    } else {
                        addPayment(); // 保存された支払いがない場合
                    }

                    totalMembersInput.value = state.totalMembers || '';
                    updateHalfMemberSelector(new Set(state.halfChecked || [])); // チェック状態を復元

                    document.querySelector(`input[name="calculation-mode"][value="${state.calcMode || 'simple'}"]`).checked = true;

                } catch (e) {
                    console.error("Failed to load state from localStorage", e);
                    addPayment(); // ロード失敗時
                }
            };

            // --- Participant & Naming ---
            const getParticipantName = (internalName) => {
                return participantNames.get(internalName) || internalName;
            };

            const setParticipantName = (internalName, newDisplayName) => {
                if (!newDisplayName) return;
                
                // 既に同じ表示名が使われていないかチェック (自分自身は除く)
                for (const [key, value] of participantNames.entries()) {
                    if (value === newDisplayName && key !== internalName) {
                        // カスタムアラートをここでも使えるが、標準alertのままでも良い
                        alert("この名前は既に使用されています。"); 
                        return;
                    }
                }
                
                participantNames.set(internalName, newDisplayName);
                updateAllPayerDropdowns();
                updateHalfMemberSelector();
                saveState();
            };

            const createPayerDropdown = (selectedPayer) => {
                const select = document.createElement('select');
                select.className = 'payer-select w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-3 text-base';
                
                participantNames.forEach((displayName, internalName) => {
                    const option = document.createElement('option');
                    option.value = internalName;
                    option.textContent = displayName;
                    if (internalName === selectedPayer) option.selected = true;
                    select.appendChild(option);
                });

                const newOption = document.createElement('option');
                newOption.value = 'new_payer';
                newOption.textContent = '新しい支払い者を追加...';
                select.appendChild(newOption);
                return select;
            };

            const updateAllPayerDropdowns = () => {
                const allSelects = document.querySelectorAll('.payer-select');
                allSelects.forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = ''; 
                    
                    participantNames.forEach((displayName, internalName) => {
                        const option = document.createElement('option');
                        option.value = internalName;
                        option.textContent = displayName;
                        select.appendChild(option);
                    });
                    const newOption = document.createElement('option');
                    newOption.value = 'new_payer';
                    newOption.textContent = '新しい支払い者を追加...';
                    select.appendChild(newOption);

                    if (participantNames.has(currentValue)) {
                        select.value = currentValue;
                    } else if (participantNames.size > 0) {
                        select.value = participantNames.keys().next().value;
                    }
                });
            };

            const updateHalfMemberSelector = (preCheckedNames = new Set()) => {
                const currentHalfChecked = new Set(
                    Array.from(halfMembersSelector.querySelectorAll('input:checked')).map(cb => cb.value)
                );
                
                const namesToCheck = new Set([...currentHalfChecked, ...preCheckedNames]);

                halfMembersSelector.innerHTML = '';
                const totalMembers = parseInt(totalMembersInput.value) || 0;
                
                const currentPayers = [...new Set(Array.from(document.querySelectorAll('.payer-select')).map(s => s.value).filter(v => v !== 'new_payer'))];
                
                const allParticipants = new Set(currentPayers);
                const nonPayerCount = totalMembers - allParticipants.size;
                
                if (nonPayerCount >= 0) {
                    for (let i = 1; i <= nonPayerCount; i++) {
                        const internalName = `参加者${i}`;
                        if (!participantNames.has(internalName)) {
                            participantNames.set(internalName, internalName);
                        }
                        allParticipants.add(internalName);
                    }
                }
                
                [...allParticipants].sort((a, b) => getParticipantName(a).localeCompare(getParticipantName(b))).forEach(internalName => {
                    const displayName = getParticipantName(internalName);
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-2 p-2 bg-gray-100 rounded-md';
                    const checkboxId = `half-checkbox-${internalName}`;
                    const isChecked = namesToCheck.has(internalName) ? 'checked' : '';
                    
                    div.innerHTML = `
                        <input type="checkbox" id="${checkboxId}" value="${internalName}" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 half-member-cb" ${isChecked}>
                        <label for="${checkboxId}" class="text-sm text-gray-700 flex-grow">${displayName}</label>
                        <button type="button" class="edit-participant-name-btn flex-shrink-0 text-gray-500 hover:text-indigo-600" data-name="${internalName}">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>
                        </button>
                    `;
                    halfMembersSelector.appendChild(div);
                });

                // イベントリスナーを再設定
                halfMembersSelector.querySelectorAll('.edit-participant-name-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const internalName = e.currentTarget.dataset.name;
                        const currentDisplayName = getParticipantName(internalName);
                        showNameEditModal(internalName, currentDisplayName, '名前を編集', setParticipantName);
                    });
                });
                halfMembersSelector.querySelectorAll('.half-member-cb').forEach(cb => {
                    cb.addEventListener('change', saveState);
                });
            };

            const addPayment = (payer = 'A', amount = '', id = null) => {
                paymentIdCounter++;
                const paymentId = id || `payment-${paymentIdCounter}`;

                const paymentEl = document.createElement('div');
                paymentEl.className = 'payment-item flex items-center gap-2';
                paymentEl.id = paymentId;
                
                const selectEl = createPayerDropdown(payer);
                const amountInput = document.createElement('input');
                amountInput.type = 'number';
                amountInput.className = "amount-input w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-3 text-base";
                amountInput.placeholder = "金額 (円)";
                amountInput.value = amount;

                paymentEl.innerHTML = `
                    <div class="flex-grow flex items-center gap-2">
                        ${selectEl.outerHTML}
                        <button type="button" class="edit-payer-name-btn flex-shrink-0 text-gray-500 hover:text-indigo-600 p-2" data-select-id="${paymentId}-select">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>
                        </button>
                    </div>
                    <div class="flex-grow">
                        ${amountInput.outerHTML}
                    </div>
                    <button type="button" class="remove-payment-btn flex-shrink-0 text-gray-400 hover:text-red-500" data-remove="${paymentId}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                    </button>
                `;
                paymentsContainer.appendChild(paymentEl);

                // イベントリスナーの動的設定
                const payerSelect = paymentEl.querySelector('.payer-select');
                payerSelect.id = `${paymentId}-select`;

                payerSelect.addEventListener('change', (e) => {
                    if (e.target.value === 'new_payer') {
                        const newPayerInternalName = String.fromCharCode(65 + participantNames.size);
                        showNameEditModal(newPayerInternalName, '', '新しい支払い者を追加', (internalName, newDisplayName) => {
                            participantNames.set(internalName, newDisplayName);
                            updateAllPayerDropdowns();
                            e.target.value = newPayerInternalName;
                            updateHalfMemberSelector();
                            saveState();
                        });
                    } else {
                        updateHalfMemberSelector();
                        saveState();
                    }
                });
                
                paymentEl.querySelector('.edit-payer-name-btn').addEventListener('click', (e) => {
                    const internalName = payerSelect.value;
                    if(internalName === 'new_payer') return;
                    const currentDisplayName = getParticipantName(internalName);
                    showNameEditModal(internalName, currentDisplayName, '支払い者を編集', setParticipantName);
                });

                paymentEl.querySelector('.remove-payment-btn').addEventListener('click', (e) => {
                    const idToRemove = e.currentTarget.getAttribute('data-remove');
                    document.getElementById(idToRemove).remove();
                    updateHalfMemberSelector();
                    saveState();
                });
                
                paymentEl.querySelector('.amount-input').addEventListener('input', saveState);

                updateHalfMemberSelector();
            };
            
            addPaymentBtn.addEventListener('click', () => addPayment(participantNames.keys().next().value));
            totalMembersInput.addEventListener('input', () => {
                updateHalfMemberSelector();
                saveState();
            });
            document.querySelectorAll('input[name="calculation-mode"]').forEach(radio => {
                radio.addEventListener('change', saveState);
            });
            
            // --- Calculation Logic (変更なし) ---
            const getBreakdown = (value) => {
                let remaining = value;
                const breakdown = [];
                for (const denom of denominations) {
                    if (remaining >= denom) {
                        const numPieces = Math.floor(remaining / denom);
                        if (numPieces > 0) breakdown.push({denom, count: numPieces});
                        remaining %= denom;
                    }
                }
                return breakdown;
            };

            const countPiecesFromBreakdown = (breakdown) => {
                return breakdown.reduce((sum, item) => sum + item.count, 0);
            };

             const getOptimalPayment = (amount) => {
                const directBreakdown = getBreakdown(amount);
                let bestOption = {
                    count: countPiecesFromBreakdown(directBreakdown),
                    payment: amount,
                    change: 0
                };

                const candidates = new Set();
                if (amount > 0) {
                    if (amount % 100 !== 0) candidates.add(Math.ceil(amount / 100) * 100);
                    if (amount % 500 !== 0) candidates.add(Math.ceil(amount / 500) * 500);
                    if (amount % 1000 !== 0) candidates.add(Math.ceil(amount / 1000) * 1000);
                    
                    const nextThousand = Math.ceil(amount/1000) * 1000;
                    if(nextThousand < 10000 && nextThousand > 0) candidates.add(nextThousand + 1000);

                    denominations.forEach(d => {
                        if (d > amount) candidates.add(d);
                    });
                }
                
                candidates.forEach(candidateAmount => {
                    if(candidateAmount <= amount) return;

                    const paymentBreakdown = getBreakdown(candidateAmount);
                    const paymentCount = countPiecesFromBreakdown(paymentBreakdown);

                    const changeAmount = candidateAmount - amount;
                    const changeBreakdown = getBreakdown(changeAmount);
                    const changeCount = countPiecesFromBreakdown(changeBreakdown);

                    const totalCount = paymentCount + changeCount;

                    if (totalCount < bestOption.count) {
                        bestOption = {
                            count: totalCount,
                            payment: candidateAmount,
                            change: changeAmount
                        };
                    }
                });
                 
                let text;
                if (bestOption.change > 0) {
                     text = `【お釣り】 ${bestOption.payment.toLocaleString()}円で払い、${bestOption.change.toLocaleString()}円のお釣りをもらう`
                } else {
                     text = `【直接払い】 ${bestOption.payment.toLocaleString()}円を支払う`
                }
                return { count: bestOption.count, text };
            };
            
            const calculateDirectSettlementCost = (balances) => {
                let cost = 0;
                const tempBalances = new Map(balances);
                const creditors = [];
                const debtors = [];
                tempBalances.forEach((amount, person) => {
                    if(amount > 0.5) creditors.push({person, amount: Math.round(amount)});
                    else if (amount < -0.5) debtors.push({person, amount: -Math.round(amount)});
                });
                
                creditors.sort((a,b) => b.amount - a.amount);
                debtors.sort((a,b) => b.amount - a.amount);

                let c = 0, d = 0;
                while(c < creditors.length && d < debtors.length){
                    const transfer = Math.min(creditors[c].amount, debtors[d].amount);
                    cost += getOptimalPayment(transfer).count;
                    creditors[c].amount -= transfer;
                    debtors[d].amount -= transfer;
                    if(creditors[c].amount < 0.5) c++;
                    if(debtors[d].amount < 0.5) d++;
                }
                return cost;
            };

            const solveCashMinimization = (initialBalances) => {
                let transactions = [];
                const tempBalances = new Map(initialBalances);

                while (true) {
                    const currentCost = calculateDirectSettlementCost(tempBalances);
                    let bestReduction = 0;
                    let bestMove = null;

                    const debtors = [];
                    tempBalances.forEach((amount, person) => {
                       if (amount < -0.5) debtors.push(person);
                    });
                    
                    const participants = Array.from(tempBalances.keys());

                    for (const from of debtors) {
                        for (const to of participants) {
                            if (from === to) continue;

                            const hypotheticalBalances = new Map(tempBalances);
                            const amountToPay = -Math.round(hypotheticalBalances.get(from));
                            
                            hypotheticalBalances.set(from, hypotheticalBalances.get(from) + amountToPay);
                            hypotheticalBalances.set(to, (hypotheticalBalances.get(to) || 0) - amountToPay);

                            const newCost = calculateDirectSettlementCost(hypotheticalBalances);
                            const moveCost = getOptimalPayment(amountToPay).count;
                            const totalNewCost = moveCost + newCost;
                            
                            const reduction = currentCost - totalNewCost;

                            if (reduction > bestReduction) {
                                bestReduction = reduction;
                                bestMove = { from, to, amount: amountToPay };
                            }
                        }
                    }

                    if (bestMove) {
                        transactions.push(bestMove);
                        const { from, to, amount } = bestMove;
                        tempBalances.set(from, tempBalances.get(from) + amount);
                        tempBalances.set(to, (tempBalances.get(to) || 0) - amount);
                    } else {
                        const finalCreditors = [], finalDebtors = [];
                        tempBalances.forEach((amount, person) => {
                            if (amount > 0.5) finalCreditors.push({ person, amount: Math.round(amount) });
                            else if (amount < -0.5) finalDebtors.push({ person, amount: -Math.round(amount) });
                        });
                         finalCreditors.sort((a, b) => b.amount - a.amount);
                        finalDebtors.sort((a, b) => b.amount - a.amount);

                        let c = 0, d = 0;
                        while(c < finalCreditors.length && d < finalDebtors.length){
                            const transfer = Math.min(finalCreditors[c].amount, finalDebtors[d].amount);
                            transactions.push({ from: finalDebtors[d].person, to: finalCreditors[c].person, amount: transfer });
                            finalCreditors[c].amount -= transfer;
                            finalDebtors[d].amount -= transfer;
                            if(finalCreditors[c].amount < 0.5) c++;
                            if(finalDebtors[d].amount < 0.5) d++;
                        }
                        break;
                    }
                }
                
                let totalCoinCost = 0;
                transactions.forEach(t => {
                    totalCoinCost += getOptimalPayment(t.amount).count;
                });

                return { transactions, totalCoinCost };
            };

            const showError = (message) => {
                resultContainer.classList.remove('hidden');
                summaryDiv.innerHTML = '';
                resultCard.innerHTML = `<p class="text-center text-red-600 font-semibold p-4">${message}</p>`;
                resultContainer.scrollIntoView({ behavior: 'smooth' });
            };

            // --- Calculate Button Event ---
            calculateBtn.addEventListener('click', () => {
                const totalMembers = parseInt(totalMembersInput.value);
                
                if (isNaN(totalMembers) || totalMembers <= 0) {
                    showError('合計人数を正しく入力してください。');
                    return;
                }

                const paymentItems = paymentsContainer.querySelectorAll('.payment-item');
                const aggregatedPayments = new Map();
                let totalPayment = 0;

                paymentItems.forEach(item => {
                    const payer = item.querySelector('.payer-select').value;
                    const amount = parseFloat(item.querySelector('.amount-input').value);
                    if (payer !== 'new_payer' && !isNaN(amount) && amount > 0) {
                        aggregatedPayments.set(payer, (aggregatedPayments.get(payer) || 0) + amount);
                        totalPayment += amount;
                    }
                });

                if (aggregatedPayments.size === 0) {
                    showError('支払いを1つ以上入力してください。');
                    return;
                }

                const halfPriceMembers = new Set(
                    Array.from(halfMembersSelector.querySelectorAll('input:checked')).map(cb => cb.value)
                );
                
                const totalHalfMembers = halfPriceMembers.size;
                const fullMembers = totalMembers - totalHalfMembers;

                if (fullMembers + totalHalfMembers * 0.5 <= 0) {
                    showError('割り勘の対象者がいません。');
                    return;
                }
                
                const payments = Array.from(aggregatedPayments, ([payer, amount]) => ({ payer, amount }));
                const totalUnits = fullMembers + totalHalfMembers * 0.5;
                const baseFullCost = Math.floor(totalPayment / totalUnits);
                const baseHalfCost = Math.floor(baseFullCost * 0.5);

                const calculatedTotal = baseFullCost * fullMembers + baseHalfCost * totalHalfMembers;
                let remainder = totalPayment - calculatedTotal;

                const finalPayerNames = Array.from(aggregatedPayments.keys());
                const allMemberNames = new Set(finalPayerNames);
                const nonPayerCount = totalMembers - finalPayerNames.length;
                if (nonPayerCount > 0) {
                    for(let i=1; i<=nonPayerCount; i++) {
                        allMemberNames.add(`参加者${i}`);
                    }
                }

                if (totalMembers !== allMemberNames.size) {
                    updateHalfMemberSelector();
                    showError('人数が一致しません。「半額払いの人を選択」のリストが最新か確認してください。');
                    return;
                }

                const memberCosts = new Map();
                allMemberNames.forEach((name) => {
                    const cost = halfPriceMembers.has(name) ? baseHalfCost : baseFullCost;
                    memberCosts.set(name, cost);
                });
                
                const calcMode = document.querySelector('input[name="calculation-mode"]:checked').value;

                if (calcMode === 'cash' && remainder > 0) {
                    for (let i = 0; i < remainder; i++) {
                        let bestPerson = null;
                        let minCost = Infinity;

                        for (const person of allMemberNames) {
                            const hypotheticalCosts = new Map(memberCosts);
                            hypotheticalCosts.set(person, hypotheticalCosts.get(person) + 1);

                            const hypotheticalBalances = new Map();
                            hypotheticalCosts.forEach((cost, name) => { hypotheticalBalances.set(name, -cost); });
                            payments.forEach(p => { hypotheticalBalances.set(p.payer, (hypotheticalBalances.get(p.payer) || 0) + p.amount); });
                            
                            const { totalCoinCost } = solveCashMinimization(hypotheticalBalances);

                            if (totalCoinCost < minCost) {
                                minCost = totalCoinCost;
                                bestPerson = person;
                            }
                        }
                         if(bestPerson) {
                             memberCosts.set(bestPerson, memberCosts.get(bestPerson) + 1);
                         } else {
                             const firstPerson = [...allMemberNames][0];
                             memberCosts.set(firstPerson, memberCosts.get(firstPerson) + 1);
                         }
                    }
                } else if (remainder > 0) {
                    const nonPayers = [...allMemberNames].filter(name => !finalPayerNames.includes(name));
                    let remainderTargets = [];
                    if (nonPayers.length > 0) {
                        remainderTargets = nonPayers;
                    } else {
                        const sortedPayers = payments.sort((a, b) => a.amount - b.amount);
                        remainderTargets = sortedPayers.map(p => p.payer);
                    }
                    for (let i = 0; i < remainder; i++) {
                        const targetPerson = remainderTargets[i % remainderTargets.length];
                        memberCosts.set(targetPerson, memberCosts.get(targetPerson) + 1);
                    }
                }

                const balances = new Map();
                memberCosts.forEach((cost, name) => { balances.set(name, -cost); });
                payments.forEach(p => { balances.set(p.payer, (balances.get(p.payer) || 0) + p.amount); });
                
                let transactions = [];
                if (calcMode === 'cash') {
                    transactions = solveCashMinimization(balances).transactions;
                } else {
                     const creditors = [], debtors = [];
                    balances.forEach((amount, person) => {
                        if (amount > 0.5) creditors.push({ person, amount });
                        else if (amount < -0.5) debtors.push({ person, amount: -amount });
                    });
                    creditors.sort((a,b) => b.amount - a.amount);
                    debtors.sort((a,b) => b.amount - a.amount);
                    let c = 0, d = 0;
                    while(c < creditors.length && d < debtors.length){
                        const transfer = Math.min(creditors[c].amount, debtors[d].amount);
                        if (transfer > 0.5) transactions.push({from: debtors[d].person, to: creditors[c].person, amount: Math.round(transfer)});
                        creditors[c].amount -= transfer;
                        debtors[d].amount -= transfer;
                        if(creditors[c].amount < 0.5) c++;
                        if(debtors[d].amount < 0.5) d++;
                    }
                }
                
                const displayFullCost = totalUnits > 0 ? Math.round(totalPayment / totalUnits) : 0;
                displayResults(transactions, totalPayment, totalMembers, displayFullCost, [...allMemberNames], calcMode);
            });
            
            const displayResults = (transactions, total, members, perPerson, allParticipants, calcMode) => {
                resultCard.innerHTML = '';
                const colorPalette = {
                    'blue-100': '#DBEAFE',
                    'green-100': '#D1FAE5',
                    'yellow-100': '#FEF3C7',
                    'purple-100': '#E9D5FF',
                    'pink-100': '#FCE7F3',
                    'red-100': '#FEE2E2',
                    'indigo-100': '#E0E7FF'
                };
                const colorKeys = ['blue-100', 'yellow-100', 'green-100', 'pink-100', 'indigo-100', 'red-100', 'purple-100'];
                const colorMap = new Map();
                const sortedParticipants = [...allParticipants].sort(); 
                sortedParticipants.forEach((person, index) => {
                    colorMap.set(person, colorPalette[colorKeys[index % colorKeys.length]]);
                });
                
                transactions.sort((a, b) => {
                    const nameA = getParticipantName(a.from);
                    const nameB = getParticipantName(b.from);
                    const getRank = (name) => (name.startsWith('参加者') ? 1 : 0);
                    const rankA = getRank(nameA);
                    const rankB = getRank(nameB);
                    if (rankA !== rankB) return rankA - rankB;
                    return nameA.localeCompare(nameB);
                });


                if (transactions.length === 0) {
                    resultCard.innerHTML = `<p class="text-center text-gray-600">精算の必要はありません。</p>`;
                } else {
                    transactions.forEach((t) => {
                        const fromColor = colorMap.get(t.from) || '#F3F4F6';
                        const toColor = colorMap.get(t.to) || '#F3F4F6';
                        
                        const resultEl = document.createElement('div');
                        resultEl.className = `p-4 rounded-lg fade-in`;
                        resultEl.style.background = `linear-gradient(to right, ${fromColor} 0%, #FFFFFF 50%, ${toColor} 100%)`;

                        const mainInfo = `
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                    <span class="font-bold text-gray-800">${getParticipantName(t.from)}</span>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-500"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                                    <span class="font-bold text-gray-800">${getParticipantName(t.to)}</span>
                                </div>
                                <span class="font-bold text-lg text-indigo-700">¥${t.amount.toLocaleString()}</span>
                            </div>
                        `;

                        let paymentDetail = '';
                        if (calcMode === 'cash') {
                            const payment = getOptimalPayment(t.amount);
                            paymentDetail = `
                                <div class="mt-3 pt-3 border-t border-gray-400 border-opacity-30">
                                    <p class="text-sm font-medium text-gray-800">支払い方法提案:</p>
                                    <p class="text-sm text-gray-600">${payment.text}</p>
                                </div>
                            `;
                        }

                        resultEl.innerHTML = mainInfo + paymentDetail;
                        resultCard.appendChild(resultEl);
                    });
                }
                
                summaryDiv.innerHTML = `
                    <strong>合計金額:</strong> ¥${total.toLocaleString()} / 
                    <strong>参加人数:</strong> ${members}人 / 
                    <strong>一人あたり(目安):</strong> 約¥${perPerson.toLocaleString()}
                `;

                resultContainer.classList.remove('hidden');
                resultContainer.scrollIntoView({ behavior: 'smooth' });
            };
            
            // --- PWA Registration ---
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            }

            // --- Initial Load ---
            loadState();
        });
    </script>
</body>
</html>
