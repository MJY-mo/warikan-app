<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WARIKAN</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#4f46e5"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WARIKAN">
    <!-- 
      以下の apple-touch-icon の href は、ご自身でアップロードした 
      180x180 (または 192x192) のアイコンパスに変更してください。
      例: href="./icon-192x192.png" 
    -->
    <link rel="apple-touch-icon" href="./icon-192x192.png"> 
    <link rel="manifest" href="manifest.json">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .shadow-soft {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
        }
        /* アコーディオン用 */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .accordion-open {
            max-height: 500px; /* 十分な高さを確保 */
            transition: max-height 0.5s ease-in;
        }
        .rotate-180 {
            transform: rotate(180deg);
        }
        .transition-transform {
            transition: transform 0.3s ease;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <!-- (修正) 左右の余白を p-4 -> p-3 に -->
    <div class="container mx-auto max-w-lg p-3 min-h-screen flex flex-col">
        <!-- ヘッダー -->
        <header class="text-center my-8 flex items-center justify-center gap-3">
            <h1 class="text-4xl font-bold text-gray-900 tracking-wider">WARIKAN</h1>
            <button id="help-btn" class="w-8 h-8 rounded-full bg-gray-200 text-gray-600 flex items-center justify-center hover:bg-gray-300 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
            </button>
        </header>

        <!-- (修正) カードの余白を p-6 -> p-4 に -->
        <main class="bg-white p-4 rounded-2xl shadow-soft flex-grow">
            <!-- 支払いリスト -->
            <div class="mb-6">
                <!-- (修正) 文字サイズ text-xs -> text-lg -->
                <label class="block text-lg font-medium text-gray-700 mb-2">1. 誰がいくら支払った？</label>
                <div id="payments-container" class="space-y-3">
                    <!-- 支払いはJSで動的に追加 -->
                </div>
                <!-- (修正) 文字サイズ text-sm -> text-xs -->
                <button id="add-payment-btn" class="mt-4 w-full flex items-center justify-center gap-2 rounded-lg border border-dashed border-gray-300 p-3 text-xs font-medium text-gray-700 hover:bg-gray-100 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus-circle"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                    支払い（レシート）を追加
                </button>
            </div>

            <!-- 参加人数 -->
            <div class="mb-6">
                <!-- (修正) 文字サイズ text-xs -> text-lg -->
                <label class="block text-lg font-medium text-gray-700 mb-2">2. 何人で割る？</label>
                <div>
                    <label for="total-members" class="text-xs text-gray-500">合計人数</label>
                    <!-- (修正) 文字/余白 text-lg p-3 -> text-base p-2.5 -->
                    <input type="number" id="total-members" min="1" class="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-base p-2.5" placeholder="例: 5">
                </div>
            </div>

            <!-- 割引設定 (アコーディオン) -->
            <div class="mb-6">
                <button id="discount-toggle-btn" class="w-full flex justify-between items-center text-left p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition">
                    <!-- (修正) 文字サイズ text-sm -> text-xs -->
                    <span class="text-xs font-medium text-gray-700">割引設定（半額・免除）</span>
                    <svg id="discount-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down transition-transform"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
                <div id="discount-content" class="accordion-content mt-2">
                    <label class="text-xs text-gray-500">割引対象の人を選択</label>
                    <div id="discount-members-selector" class="mt-2 grid grid-cols-1 sm:grid-cols-2 gap-2">
                        <!-- 割引対象者はJSで動的に追加 -->
                    </div>
                </div>
            </div>
            
            <!-- 精算方法 -->
            <div class="mb-6">
                <!-- (修正) 文字サイズ text-xs -> text-lg -->
                <label class="block text-lg font-medium text-gray-700 mb-2">3. やり取りの計算方法</label>
                <fieldset class="mt-2">
                    <div class="flex items-center space-x-6">
                        <div class="flex items-center">
                            <input id="mode-simple" name="calculation-mode" type="radio" value="simple" checked class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <!-- (修正) 文字サイズ text-sm -> text-xs -->
                            <label for="mode-simple" class="ml-2 block text-xs text-gray-900">直接計算</label>
                        </div>
                        <div class="flex items-center">
                            <input id="mode-cash" name="calculation-mode" type="radio" value="cash" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500">
                            <!-- (修正) 文字サイズ text-sm -> text-xs -->
                            <label for="mode-cash" class="ml-2 block text-xs text-gray-900">硬貨・紙幣の枚数が最少</label>
                        </div>
                    </div>
                </fieldset>
            </div>

            <!-- 計算ボタン -->
            <!-- (修正) 文字サイズ text-lg -> text-base -->
            <button id="calculate-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-base">
                計算する
            </button>
        </main>

        <!-- 結果表示エリア -->
        <div id="result-container" class="mt-8 hidden">
            <!-- (修正) 文字サイズ text-2xl -> text-xl -->
            <h2 class="text-xl font-bold text-center mb-4">計算結果</h2>
            <div id="result-card" class="bg-white p-6 rounded-2xl shadow-soft space-y-3">
                <!-- 結果はJSで動的に追加 -->
            </div>
            <!-- (修正) 文字サイズ text-sm -> text-xs -->
            <div id="summary" class="mt-4 text-center text-xs text-gray-600 bg-gray-100 p-3 rounded-lg"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-md w-full m-4 flex flex-col" style="max-height: 90vh;">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold text-gray-900">操作</h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                </button>
            </div>
            <!-- (修正) モーダル内容をスクロール可能に -->
            <div class="text-gray-700 space-y-4 overflow-y-auto">
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">操作</h4>
                    <ol class="list-decimal list-inside space-y-1 text-sm">
                        <li>「支払い（レシート）を追加」で立て替えた人の情報と金額を入力します。</li>
                        <li>支払者の名前は、ドロップダウン横の鉛筆ボタン、または「割引設定」のリストから編集できます。</li>
                        <li>金額を割る合計人数を入力します。立て替えた人も含めた総人数です。</li>
                        <li>「割引設定」を開き、半額や全額免除の人を指定できます。</li>
                        <li>やり取りの計算方法を選んで計算するボタンを押してください。</li>
                    </ol>
                </div>
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">端数の取り扱いについて</h4>
                    <p class="text-sm">割り切れない端数が出た場合、その負担者は計算方法によって自動的に最適化されます。</p>
                    <ul class="list-disc list-inside space-y-1 text-sm mt-2">
                        <li><strong>直接計算：</strong>支払いをしていない人（または支払額が少ない人）から順に1円ずつ負担します。</li>
                        <li><strong>硬貨・紙幣の枚数が最少：</strong> 全員のやり取りで、硬貨・紙幣の総移動枚数が最も少なくなる人が端数を負担します。</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold text-gray-800 mb-2">データについて</h4>
                    <p class="text-sm">入力内容は自動でブラウザに保存されます。アプリを閉じてもデータは消えません。リセットしたい場合は、各項目の入力（金額など）を削除してください。</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Name Edit Modal -->
    <div id="name-edit-modal" class="fixed inset-0 bg-gray-600 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-sm w-full m-4">
            <h3 class="text-xl font-bold text-gray-900 mb-4" id="name-edit-title">名前の編集</h3>
            <input type="text" id="name-edit-input" class="w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-lg p-3" placeholder="例: 田中">
            <input type="hidden" id="name-edit-old-id">
            <div class="mt-6 flex justify-end gap-3">
                <button id="name-edit-cancel" type="button" class="px-4 py-2 rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 transition">キャンセル</button>
                <button id="name-edit-save" type="button" class="px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition">保存</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const paymentsContainer = document.getElementById('payments-container');
            const addPaymentBtn = document.getElementById('add-payment-btn');
            const calculateBtn = document.getElementById('calculate-btn');
            const totalMembersInput = document.getElementById('total-members');
            const discountToggleBtn = document.getElementById('discount-toggle-btn');
            const discountArrow = document.getElementById('discount-arrow');
            const discountContent = document.getElementById('discount-content');
            const discountMembersSelector = document.getElementById('discount-members-selector');
            const resultContainer = document.getElementById('result-container');
            const resultCard = document.getElementById('result-card');
            const summaryDiv = document.getElementById('summary');
            
            // Modals
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            const nameEditModal = document.getElementById('name-edit-modal');
            const nameEditInput = document.getElementById('name-edit-input');
            const nameEditOldId = document.getElementById('name-edit-old-id');
            const nameEditCancel = document.getElementById('name-edit-cancel');
            const nameEditSave = document.getElementById('name-edit-save');

            // 参加者IDと名前のマッピング
            // { id: 'p1', name: '自分' }, { id: 'p2', name: '参加者2' } ...
            let participants = [];
            let paymentIdCounter = 0;
            const denominations = [10000, 5000, 1000, 500, 100, 50, 10, 5, 1];
            const STORAGE_KEY = 'warikanAppState_v3';

            // --- Modal Control (Help) ---
            helpBtn.addEventListener('click', () => helpModal.classList.remove('hidden'));
            closeModalBtn.addEventListener('click', () => helpModal.classList.add('hidden'));
            helpModal.addEventListener('click', (e) => {
                if(e.target === helpModal) {
                    helpModal.classList.add('hidden');
                }
            });

            // --- Modal Control (Name Edit) ---
            let nameEditCallback = null;

            const showNameEditModal = (oldId, oldName, callback) => {
                nameEditInput.value = oldName;
                nameEditOldId.value = oldId;
                nameEditCallback = callback;
                nameEditModal.classList.remove('hidden');
                nameEditInput.focus();
                nameEditInput.select();
            };

            const hideNameEditModal = () => {
                nameEditModal.classList.add('hidden');
                nameEditCallback = null;
            };

            nameEditCancel.addEventListener('click', hideNameEditModal);
            // (修正) oldId のチェックを削除
            nameEditSave.addEventListener('click', () => {
                const newName = nameEditInput.value.trim();
                const oldId = nameEditOldId.value;
                // (修正) newName があり、コールバックが設定されていれば実行
                if (newName && newName.length > 0 && nameEditCallback) {
                    nameEditCallback(oldId, newName); // oldId は 'new_payer_id' または p-XXXX
                }
                hideNameEditModal();
            });

            // --- Accordion Control ---
            discountToggleBtn.addEventListener('click', () => {
                discountContent.classList.toggle('accordion-open');
                discountArrow.classList.toggle('rotate-180');
            });

            // --- Participant Management ---
            const getParticipantName = (id) => {
                const p = participants.find(p => p.id === id);
                return p ? p.name : '不明';
            };
            
            const getParticipantById = (id) => {
                return participants.find(p => p.id === id);
            };

            const setParticipantName = (id, newName) => {
                const p = participants.find(p => p.id === id);
                if (p) {
                    p.name = newName;
                    console.log(`Name updated: ${id} -> ${newName}`);
                    // UI全体を更新
                    updateAllPayerDropdowns();
                    updateDiscountMemberSelector();
                    saveState();
                } else {
                    console.warn(`Participant not found for ID: ${id}`);
                }
            };
            
            const createNewParticipant = (name) => {
                const newId = `p${Date.now()}${Math.floor(Math.random()*100)}`; // 衝突しないユニークID
                const newP = { id: newId, name: name };
                // participants.push(newP); // (削除) グローバルを触らない
                console.log(`New participant created: ${newId} (${name})`);
                return newP;
            };


            const showError = (message) => {
                resultContainer.classList.remove('hidden');
                summaryDiv.innerHTML = '';
                resultCard.innerHTML = `<p class="text-center text-red-600 font-semibold p-4">${message}</p>`;
                resultContainer.scrollIntoView({ behavior: 'smooth' });
            };

            const createPayerDropdown = (selectedPayerId) => {
                const select = document.createElement('select');
                // (修正) 文字/余白 text-base p-3 -> text-sm p-2.5
                select.className = 'payer-select w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm p-2.5';
                
                // 支払者に限定せず、全参加者をドロップダウンに表示
                participants.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p.id;
                    option.textContent = p.name;
                    if (p.id === selectedPayerId) option.selected = true;
                    select.appendChild(option);
                });

                const newOption = document.createElement('option');
                newOption.value = 'new_payer';
                newOption.textContent = '新しい支払い者を追加...';
                select.appendChild(newOption);
                return select;
            };

            const updateAllPayerDropdowns = () => {
                const allSelects = document.querySelectorAll('.payer-select');
                allSelects.forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = ''; 
                    
                    participants.forEach(p => {
                        const option = document.createElement('option');
                        option.value = p.id;
                        option.textContent = p.name;
                        select.appendChild(option);
                    });
                    const newOption = document.createElement('option');
                    newOption.value = 'new_payer';
                    newOption.textContent = '新しい支払い者を追加...';
                    select.appendChild(newOption);

                    // IDが参加者リストに存在するかで判定
                    if (participants.some(p => p.id === currentValue)) {
                        select.value = currentValue;
                    } else {
                        select.value = participants.length > 0 ? participants[0].id : 'new_payer';
                    }
                });
            };

            const updateDiscountMemberSelector = () => {
                // 1. 現在のチェック状態を保存
                const currentDiscounts = new Map();
                discountMembersSelector.querySelectorAll('input[type="radio"]').forEach(radio => {
                    if (radio.checked) {
                        currentDiscounts.set(radio.name.replace('discount-', ''), radio.value);
                    }
                });
                
                // 2. DOMをクリア
                discountMembersSelector.innerHTML = '';
                
                // 3. 必要な情報を取得
                const totalMembers = parseInt(totalMembersInput.value) || 0;
                const currentPayerIds = new Set(Array.from(document.querySelectorAll('.payer-select')).map(s => s.value).filter(v => v !== 'new_payer'));
                
                let newParticipants = [];
                
                // 4. 支払者 + カスタム名の人を優先的に保持
                const essentialParticipantIds = new Set(currentPayerIds);
                const customNamedNonPayers = [];
                
                for (const p of participants) {
                    if (currentPayerIds.has(p.id)) {
                        newParticipants.push(p);
                    } else if (!/^参加者(\d+)$/.test(p.name)) {
                        // 支払者ではなく、デフォルト名でもない (カスタム名)
                        customNamedNonPayers.push(p);
                        essentialParticipantIds.add(p.id); // 必須リストに追加
                    }
                }
                newParticipants.push(...customNamedNonPayers);

                // 5. 必須の人の数と合計人数を比較
                const currentNum = newParticipants.length;
                
                if (currentNum < totalMembers) {
                    // 枠が余っている -> 既存の「参加者X」で埋め、足りなければ新規作成
                    
                    // 既存の「参加者X」
                    const defaultNamedNonPayers = participants.filter(p => 
                        !essentialParticipantIds.has(p.id) && /^参加者(\d+)$/.test(p.name)
                    );
                    
                    let slotsToFill = totalMembers - currentNum;
                    
                    // 既存の「参加者X」で埋める
                    for (const p of defaultNamedNonPayers) {
                        if (slotsToFill > 0) {
                            newParticipants.push(p);
                            slotsToFill--;
                        }
                    }
                    
                    // まだ枠が余るなら新規作成
                    if (slotsToFill > 0) {
                        let participantCounter = 1;
                        newParticipants.forEach(p => { // (修正) newParticipants を走査
                            const match = p.name.match(/^参加者(\d+)$/);
                            if (match) {
                                const num = parseInt(match[1]);
                                if (num >= participantCounter) {
                                    participantCounter = num + 1;
                                }
                            }
                        });

                        for (let i = 0; i < slotsToFill; i++) {
                            const newP = createNewParticipant(`参加者${participantCounter + i}`);
                            newParticipants.push(newP);
                        }
                    }
                    
                } else if (currentNum > totalMembers) {
                    // 人数オーバー -> カスタム名の非支払者を削除
                    let numToRemove = currentNum - totalMembers;
                    
                    // カスタム名の非支払者 (customNamedNonPayers) を後ろから削除
                    newParticipants = newParticipants.filter(p => {
                        // (修正) 支払者でなく、かつカスタム名の人を削除対象
                        if (numToRemove > 0 && !currentPayerIds.has(p.id) && customNamedNonPayers.some(cnp => cnp.id === p.id)) {
                            numToRemove--;
                            return false; // 削除
                        }
                        return true; // 保持
                    });
                }
                
                // 6. participants 配列を更新
                participants = newParticipants;

                // 7. DOMを再構築
                const sortedParticipants = [...participants].sort((a, b) => a.name.localeCompare(b.name, 'ja'));
                
                sortedParticipants.forEach(p => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between gap-2 p-3 bg-gray-100 rounded-md';
                    
                    const nameAndEdit = document.createElement('div');
                    nameAndEdit.className = 'flex items-center gap-2';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `discount-none-${p.id}`;
                    // (修正) 文字サイズ text-sm -> text-xs
                    label.className = 'text-xs text-gray-700 font-medium';
                    label.textContent = p.name;
                    
                    const editBtn = document.createElement('button');
                    editBtn.type = 'button';
                    editBtn.className = 'edit-participant-btn text-gray-400 hover:text-indigo-600 transition';
                    editBtn.dataset.participantId = p.id;
                    editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4L18.5 2.5z"></path></svg>`;
                    editBtn.addEventListener('click', (e) => {
                        const id = e.currentTarget.dataset.participantId;
                        const participant = getParticipantById(id); // getParticipantById はグローバル `participants` を見るのでOK
                        if (participant) {
                            showNameEditModal(participant.id, participant.name, (oldId, newName) => {
                                setParticipantName(oldId, newName);
                            });
                        }
                    });

                    nameAndEdit.appendChild(label);
                    nameAndEdit.appendChild(editBtn);
                    
                    // (修正) 割引オプション (半額・免除)
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'flex items-center gap-3';
                    
                    const radioName = `discount-${p.id}`;
                    const discountType = currentDiscounts.get(p.id) || 'none'; // ステップ1で保存した値

                    optionsDiv.innerHTML = `
                        <div class="flex items-center">
                            <input type="radio" id="discount-none-${p.id}" name="${radioName}" value="none" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${discountType === 'none' ? 'checked' : ''}>
                            <label for="discount-none-${p.id}" class="ml-1 text-xs text-gray-600">なし</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="discount-half-${p.id}" name="${radioName}" value="half" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${discountType === 'half' ? 'checked' : ''}>
                            <label for="discount-half-${p.id}" class="ml-1 text-xs text-gray-600">半額</label>
                        </div>
                        <div class="flex items-center">
                            <input type="radio" id="discount-zero-${p.id}" name="${radioName}" value="zero" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${discountType === 'zero' ? 'checked' : ''}>
                            <label for="discount-zero-${p.id}" class="ml-1 text-xs text-gray-600">免除</label>
                        </div>
                    `;
                    
                    optionsDiv.addEventListener('change', saveState); // ラジオボタン変更時にも保存

                    div.appendChild(nameAndEdit);
                    div.appendChild(optionsDiv);
                    discountMembersSelector.appendChild(div);
                });
                
                // 8. 支払いドロップダウンも同期
                updateAllPayerDropdowns();
                // 9. 保存
                saveState();
            };

            const addPayment = (payment = null) => {
                paymentIdCounter++;
                const paymentId = `payment-${paymentIdCounter}`;

                const paymentEl = document.createElement('div');
                paymentEl.className = 'payment-item flex items-center gap-2';
                paymentEl.id = paymentId;
                
                // 支払い者ID（p1, p2など）を渡す
                const defaultPayerId = (payment && payment.payerId) ? payment.payerId : (participants.length > 0 ? participants[0].id : null);
                const selectEl = createPayerDropdown(defaultPayerId);

                paymentEl.innerHTML = `
                    <!-- (修正) w-2/5 -> flex-grow (名前欄を広げる) -->
                    <div class="flex-grow relative">
                        ${selectEl.outerHTML}
                    </div>
                    <!-- (修正) 編集ボタンを追加 -->
                    <button type="button" class="edit-payer-btn flex-shrink-0 text-gray-400 hover:text-indigo-600 transition">
                         <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4L18.5 2.5z"></path></svg>
                    </button>
                    <!-- (修正) flex-grow -> w-28 (金額欄を固定幅に) -->
                    <div class="w-28">
                        <!-- (修正) 文字/余白 text-base p-3 -> text-sm p-2.5 -->
                        <input type="number" class="amount-input w-full rounded-lg border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-sm p-2.5" placeholder="金額 (円)" value="${payment && payment.amount ? payment.amount : ''}">
                    </div>
                    <button type="button" class="remove-payment-btn flex-shrink-0 text-gray-400 hover:text-red-500 transition" data-remove="${paymentId}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                    </button>
                `;
                paymentsContainer.appendChild(paymentEl);

                // --- Event Listeners for new payment item ---

                const payerSelect = paymentEl.querySelector('.payer-select');
                
                payerSelect.addEventListener('change', (e) => {
                    if (e.target.value === 'new_payer') {
                        // 新しい支払い者を追加
                        // (修正) 'new_payer_id' を渡す
                        showNameEditModal('new_payer_id', '', (oldId, newName) => {
                            const newP = createNewParticipant(newName);
                            participants.push(newP); // (修正) グローバル配列に追加
                            // ドロップダウンを更新
                            updateAllPayerDropdowns();
                            // 割引リストも更新
                            updateDiscountMemberSelector();
                            // 今のドロップダウンの選択肢を新しい参加者に変更
                            e.target.value = newP.id;
                            saveState();
                        });
                    } else {
                         saveState(); // 既存の支払い者を選んだ場合も保存
                    }
                });
                
                // (追加) 支払い者リスト横の編集ボタン
                paymentEl.querySelector('.edit-payer-btn').addEventListener('click', (e) => {
                     const selectedId = payerSelect.value;
                     if (selectedId && selectedId !== 'new_payer') {
                         const participant = getParticipantById(selectedId);
                         if(participant) {
                            showNameEditModal(participant.id, participant.name, (oldId, newName) => {
                                setParticipantName(oldId, newName);
                            });
                         }
                     }
                });


                paymentEl.querySelector('.remove-payment-btn').addEventListener('click', (e) => {
                    const idToRemove = e.currentTarget.getAttribute('data-remove');
                    document.getElementById(idToRemove).remove();
                    // 支払い者がいなくなったかチェック
                    updateDiscountMemberSelector(); // 支払い者が0になったら参加者リストからも消える可能性があるため
                    saveState();
                });
                
                paymentEl.querySelector('.amount-input').addEventListener('input', saveState);

                // 初期読み込み時以外は、割引セレクターを更新
                if (payment === null) {
                    updateDiscountMemberSelector();
                    saveState();
                }
            };
            
            // --- State Management (localStorage) ---
            const saveState = () => {
                try {
                    const payments = [];
                    paymentsContainer.querySelectorAll('.payment-item').forEach(item => {
                        const payerId = item.querySelector('.payer-select').value;
                        const amount = parseFloat(item.querySelector('.amount-input').value);
                        if (payerId !== 'new_payer' && !isNaN(amount) && amount > 0) {
                            payments.push({ payerId, amount });
                        }
                    });
                    
                    const discounts = {};
                    discountMembersSelector.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                        const id = radio.name.replace('discount-', '');
                        discounts[id] = radio.value; // 'none', 'half', 'zero'
                    });

                    const state = {
                        participants: participants, // 参加者リスト（IDと名前）
                        payments: payments, // 支払いリスト
                        totalMembers: totalMembersInput.value,
                        discounts: discounts, // 割引状態
                        calcMode: document.querySelector('input[name="calculation-mode"]:checked').value
                    };
                    
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                    console.log('State saved.');

                } catch (e) {
                    console.error("Failed to save state:", e);
                }
            };

            const loadState = () => {
                let state;
                try {
                    const savedState = localStorage.getItem(STORAGE_KEY);
                    if (!savedState) {
                        console.log('No saved state found. Initializing.');
                        // (修正) デフォルト名を「自分」に
                        const defaultParticipant = createNewParticipant('自分');
                        participants.push(defaultParticipant); // (修正) 配列に追加
                        addPayment(); // 空の支払い項目を1つ追加
                        updateDiscountMemberSelector(); // 人数(1)に基づいて更新
                        return; // 初期化終了
                    }
                    
                    state = JSON.parse(savedState);
                    console.log('State loaded:', state);

                    if (!state || !state.participants) {
                         // v3より古いデータ構造、またはデータ破損
                        throw new Error('Invalid state structure.');
                    }

                } catch (e) {
                    console.warn('Failed to parse state or invalid state structure. Resetting state.', e);
                    localStorage.removeItem(STORAGE_KEY);
                    // (修正) デフォルト名を「自分」に
                    const defaultParticipant = createNewParticipant('自分');
                    participants.push(defaultParticipant); // (修正) 配列に追加
                    addPayment();
                    updateDiscountMemberSelector();
                    return;
                }

                // ---------------------------------
                // 状態の復元
                // ---------------------------------
                
                // 1. 参加者リストの復元
                if (state.participants && Array.isArray(state.participants)) {
                    participants = state.participants;
                } else {
                    // 参加者リストがない（古い）場合は、支払い者から推測
                    participants = [];
                    // ... （ただしv3ではparticipantsは必須のはず）
                }

                // 2. 合計人数の復元
                if (state.totalMembers) {
                    totalMembersInput.value = state.totalMembers;
                }
                
                // 3. 割引セレクターの生成 (人数と参加者リストに基づいて)
                // この時点で discounts (state.discounts) はまだ適用しない
                updateDiscountMemberSelector();

                // 4. 支払いリストの復元
                paymentsContainer.innerHTML = ''; // コンテナをクリア
                if (state.payments && state.payments.length > 0) {
                    state.payments.forEach(p => {
                        // 支払い者IDが存在するか確認
                        if (participants.some(pa => pa.id === p.payerId)) {
                             addPayment(p); // 支払い項目を復元
                        } else {
                            console.warn(`Saved payment references non-existent participant ID ${p.payerId}. Skipping.`);
                        }
                    });
                } else if (participants.length > 0) {
                    // 支払いが0件でも、参加者がいれば空のフォームを1つ出す
                     addPayment();
                } else {
                    // 参加者も支払いも0件（＝完全な初期状態）
                    const defaultParticipant = createNewParticipant('自分');
                    participants.push(defaultParticipant); // (修正) 配列に追加
                    addPayment();
                }
                
                // 5. 割引状態の復元 (セレクターが生成された後に実行)
                if (state.discounts) {
                    Object.keys(state.discounts).forEach(participantId => {
                        const radio = document.querySelector(`input[name="discount-${participantId}"][value="${state.discounts[participantId]}"]`);
                        if (radio) {
                            radio.checked = true;
                        }
                    });
                }
                
                // 6. 計算モードの復元
                if (state.calcMode) {
                    const modeRadio = document.getElementById(`mode-${state.calcMode}`);
                    if(modeRadio) modeRadio.checked = true;
                }
            };
            

            // --- Event Listeners (Global) ---
            addPaymentBtn.addEventListener('click', () => addPayment());
            totalMembersInput.addEventListener('input', () => {
                updateDiscountMemberSelector();
                // saveState(); (updateDiscountMemberSelector内で呼ばれる)
            });
            
            // 計算モードのラジオボタンにも保存イベントを追加
            document.querySelectorAll('input[name="calculation-mode"]').forEach(radio => {
                radio.addEventListener('change', saveState);
            });


            // --- Calculation Logic ---

            const getBreakdown = (value) => {
                let remaining = value;
                const breakdown = [];
                for (const denom of denominations) {
                    if (remaining >= denom) {
                        const numPieces = Math.floor(remaining / denom);
                        if (numPieces > 0) breakdown.push({denom, count: numPieces});
                        remaining %= denom;
                    }
                }
                return breakdown;
            };

            const countPiecesFromBreakdown = (breakdown) => {
                return breakdown.reduce((sum, item) => sum + item.count, 0);
            };

             const getOptimalPayment = (amount) => {
                const directBreakdown = getBreakdown(amount);
                let bestOption = {
                    count: countPiecesFromBreakdown(directBreakdown),
                    payment: amount,
                    change: 0
                };

                const candidates = new Set();
                if (amount > 0) {
                    if (amount % 100 !== 0) candidates.add(Math.ceil(amount / 100) * 100);
                    if (amount % 500 !== 0) candidates.add(Math.ceil(amount / 500) * 500);
                    if (amount % 1000 !== 0) candidates.add(Math.ceil(amount / 1000) * 1000);
                    
                    const nextThousand = Math.ceil(amount/1000) * 1000;
                    if(nextThousand < 10000 && nextThousand > 0) candidates.add(nextThousand + 1000);

                    denominations.forEach(d => {
                        if (d > amount) candidates.add(d);
                    });
                }
                
                candidates.forEach(candidateAmount => {
                    if(candidateAmount <= amount) return;

                    const paymentBreakdown = getBreakdown(candidateAmount);
                    const paymentCount = countPiecesFromBreakdown(paymentBreakdown);

                    const changeAmount = candidateAmount - amount;
                    const changeBreakdown = getBreakdown(changeAmount);
                    const changeCount = countPiecesFromBreakdown(changeBreakdown);

                    const totalCount = paymentCount + changeCount;

                    if (totalCount < bestOption.count) {
                        bestOption = {
                            count: totalCount,
                            payment: candidateAmount,
                            change: changeAmount
                        };
                    }
                });
                 
                let text;
                if (bestOption.change > 0) {
                     text = `【お釣り】 ${bestOption.payment.toLocaleString()}円で払い、${bestOption.change.toLocaleString()}円のお釣りをもらう`
                } else {
                     text = `【直接払い】 ${bestOption.payment.toLocaleString()}円を支払う`
                }
                return { count: bestOption.count, text };
            };
            
            const calculateDirectSettlementCost = (balances) => {
                let cost = 0;
                const tempBalances = new Map(balances);
                const creditors = [];
                const debtors = [];
                tempBalances.forEach((amount, person) => {
                    if(amount > 0.5) creditors.push({person, amount: Math.round(amount)});
                    else if (amount < -0.5) debtors.push({person, amount: -Math.round(amount)});
                });
                
                creditors.sort((a,b) => b.amount - a.amount);
                debtors.sort((a,b) => b.amount - a.amount);

                let c = 0, d = 0;
                while(c < creditors.length && d < debtors.length){
                    const transfer = Math.min(creditors[c].amount, debtors[d].amount);
                    cost += getOptimalPayment(transfer).count;
                    creditors[c].amount -= transfer;
                    debtors[d].amount -= transfer;
                    if(creditors[c].amount < 0.5) c++;
                    if(debtors[d].amount < 0.5) d++;
                }
                return cost;
            };

            const solveCashMinimization = (initialBalances) => {
                let transactions = [];
                const tempBalances = new Map(initialBalances);

                while (true) {
                    const currentCost = calculateDirectSettlementCost(tempBalances);
                    let bestReduction = 0;
                    let bestMove = null;

                    const debtors = [];
                    tempBalances.forEach((amount, person) => {
                       if (amount < -0.5) debtors.push(person);
                    });
                    
                    const participants = Array.from(tempBalances.keys());

                    for (const from of debtors) {
                        for (const to of participants) {
                            if (from === to) continue;

                            const hypotheticalBalances = new Map(tempBalances);
                            const amountToPay = -Math.round(hypotheticalBalances.get(from));
                            
                            hypotheticalBalances.set(from, hypotheticalBalances.get(from) + amountToPay);
                            hypotheticalBalances.set(to, hypotheticalBalances.get(to) - amountToPay);

                            const newCost = calculateDirectSettlementCost(hypotheticalBalances);
                            const moveCost = getOptimalPayment(amountToPay).count;
                            const totalNewCost = moveCost + newCost;
                            
                            const reduction = currentCost - totalNewCost;

                            if (reduction > bestReduction) {
                                bestReduction = reduction;
                                bestMove = { from, to, amount: amountToPay };
                            }
                        }
                    }

                    if (bestMove) {
                        transactions.push(bestMove);
                        const { from, to, amount } = bestMove;
                        tempBalances.set(from, tempBalances.get(from) + amount);
                        tempBalances.set(to, tempBalances.get(to) - amount);
                    } else {
                        const finalCreditors = [], finalDebtors = [];
                        tempBalances.forEach((amount, person) => {
                            if (amount > 0.5) finalCreditors.push({ person, amount: Math.round(amount) });
                            else if (amount < -0.5) finalDebtors.push({ person, amount: -Math.round(amount) });
                        });
                         finalCreditors.sort((a, b) => b.amount - a.amount);
                        finalDebtors.sort((a, b) => b.amount - a.amount);

                        let c = 0, d = 0;
                        while(c < finalCreditors.length && d < finalDebtors.length){
                            const transfer = Math.min(finalCreditors[c].amount, finalDebtors[d].amount);
                            transactions.push({ from: finalDebtors[d].person, to: finalCreditors[c].person, amount: transfer });
                            finalCreditors[c].amount -= transfer;
                            finalDebtors[d].amount -= transfer;
                            if(finalCreditors[c].amount < 0.5) c++;
                            if(finalDebtors[d].amount < 0.5) d++;
                        }
                        break;
                    }
                }
                
                let totalCoinCost = 0;
                transactions.forEach(t => {
                    totalCoinCost += getOptimalPayment(t.amount).count;
                });

                return { transactions, totalCoinCost };
            };

            calculateBtn.addEventListener('click', () => {
                const totalMembers = parseInt(totalMembersInput.value);
                
                if (isNaN(totalMembers) || totalMembers <= 0) {
                    showError('合計人数を正しく入力してください。');
                    return;
                }
                
                // (修正) participants が人数と一致しているか確認
                if (totalMembers !== participants.length) {
                    showError('合計人数と参加者リストの数が一致しません。「割引設定」で参加者リストを更新してください。');
                    // updateDiscountMemberSelector(); // 自動更新も可能だが、一旦エラー表示
                    return;
                }

                const paymentItems = paymentsContainer.querySelectorAll('.payment-item');
                const aggregatedPayments = new Map(); // K: participantId, V: amount
                let totalPayment = 0;

                paymentItems.forEach(item => {
                    const payerId = item.querySelector('.payer-select').value;
                    const amount = parseFloat(item.querySelector('.amount-input').value);
                    if (payerId !== 'new_payer' && !isNaN(amount) && amount > 0) {
                        aggregatedPayments.set(payerId, (aggregatedPayments.get(payerId) || 0) + amount);
                        totalPayment += amount;
                    }
                });

                if (aggregatedPayments.size === 0 && totalPayment === 0) {
                    // 支払い0円の場合は計算結果をクリアして終了
                    resultContainer.classList.add('hidden');
                    resultCard.innerHTML = '';
                    summaryDiv.innerHTML = '';
                    return;
                }
                
                // (修正) 割引設定の取得
                const discountMap = new Map(); // K: participantId, V: 'none' | 'half' | 'zero'
                discountMembersSelector.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                    const id = radio.name.replace('discount-', '');
                    discountMap.set(id, radio.value);
                });
                
                let totalHalfMembers = 0;
                let totalZeroMembers = 0;
                
                participants.forEach(p => {
                    const type = discountMap.get(p.id) || 'none';
                    if (type === 'half') totalHalfMembers++;
                    else if (type === 'zero') totalZeroMembers++;
                });

                const fullMembers = totalMembers - totalHalfMembers - totalZeroMembers;
                const totalUnits = fullMembers + totalHalfMembers * 0.5;

                if (totalUnits <= 0) {
                    if (totalPayment > 0) {
                        showError('割り勘の対象者（全額負担の人）が1人もいません。');
                        return;
                    }
                    // 全員免除で支払い0円ならOK (上でリターン済み)
                }
                
                const baseFullCost = (totalUnits > 0) ? Math.floor(totalPayment / totalUnits) : 0;
                const baseHalfCost = Math.floor(baseFullCost * 0.5);
                const baseZeroCost = 0;

                const calculatedTotal = (baseFullCost * fullMembers) + (baseHalfCost * totalHalfMembers);
                let remainder = totalPayment - calculatedTotal;

                const memberCosts = new Map(); // K: participantId, V: cost
                participants.forEach((p) => {
                    const type = discountMap.get(p.id) || 'none';
                    let cost = 0;
                    if (type === 'half') cost = baseHalfCost;
                    else if (type === 'zero') cost = baseZeroCost;
                    else cost = baseFullCost;
                    memberCosts.set(p.id, cost);
                });
                
                const calcMode = document.querySelector('input[name="calculation-mode"]:checked').value;

                if (remainder > 0) {
                    // 端数処理
                    // (修正) 免除(zero)の人を除外して端数を割り当てる
                    const remainderTargets = participants.filter(p => (discountMap.get(p.id) || 'none') !== 'zero');

                    if (remainderTargets.length === 0) {
                        // (起こり得ないはずだが) 全員免除なのに端数が出た場合
                        console.warn("Remainder exists but no one to assign to.");
                    } else if (calcMode === 'cash') {
                         for (let i = 0; i < remainder; i++) {
                            let bestPersonId = null;
                            let minCost = Infinity;

                            for (const p of remainderTargets) {
                                const hypotheticalCosts = new Map(memberCosts);
                                hypotheticalCosts.set(p.id, hypotheticalCosts.get(p.id) + 1);

                                const hypotheticalBalances = new Map();
                                hypotheticalCosts.forEach((cost, id) => { hypotheticalBalances.set(id, -cost); });
                                aggregatedPayments.forEach((amount, id) => { hypotheticalBalances.set(id, (hypotheticalBalances.get(id) || 0) + amount); });
                                
                                const { totalCoinCost } = solveCashMinimization(hypotheticalBalances);

                                if (totalCoinCost < minCost) {
                                    minCost = totalCoinCost;
                                    bestPersonId = p.id;
                                }
                            }
                             if(bestPersonId) {
                                 memberCosts.set(bestPersonId, memberCosts.get(bestPersonId) + 1);
                             } else {
                                 memberCosts.set(remainderTargets[0].id, memberCosts.get(remainderTargets[0].id) + 1);
                             }
                        }
                    } else {
                        // シンプル計算: 支払いがない人、または支払いが少ない人から順に割り当て
                        // (修正) 免除者を除いたリストでソート
                        const sortedTargets = remainderTargets.sort((a, b) => {
                            const paymentA = aggregatedPayments.get(a.id) || 0;
                            const paymentB = aggregatedPayments.get(b.id) || 0;
                            return paymentA - paymentB;
                        });

                        for (let i = 0; i < remainder; i++) {
                            const targetPersonId = sortedTargets[i % sortedTargets.length].id;
                            memberCosts.set(targetPersonId, memberCosts.get(targetPersonId) + 1);
                        }
                    }
                }

                const balances = new Map(); // K: participantId, V: balance
                memberCosts.forEach((cost, id) => { balances.set(id, -cost); });
                aggregatedPayments.forEach((amount, id) => { balances.set(id, (balances.get(id) || 0) + amount); });
                
                let transactions = [];
                if (calcMode === 'cash') {
                    transactions = solveCashMinimization(balances).transactions;
                } else {
                     const creditors = [], debtors = [];
                    balances.forEach((amount, personId) => {
                        if (amount > 0.5) creditors.push({ personId, amount });
                        else if (amount < -0.5) debtors.push({ personId, amount: -amount });
                    });
                    creditors.sort((a,b) => b.amount - a.amount);
                    debtors.sort((a,b) => b.amount - a.amount);
                    let c = 0, d = 0;
                    while(c < creditors.length && d < debtors.length){
                        const transfer = Math.min(creditors[c].amount, debtors[d].amount);
                        if (transfer > 0.5) transactions.push({from: debtors[d].personId, to: creditors[c].personId, amount: Math.round(transfer)});
                        creditors[c].amount -= transfer;
                        debtors[d].amount -= transfer;
                        if(creditors[c].amount < 0.5) c++;
                        if(debtors[d].amount < 0.5) d++;
                    }
                }
                
                const displayFullCost = totalUnits > 0 ? Math.round(totalPayment / totalUnits) : 0;
                displayResults(transactions, totalPayment, totalMembers, displayFullCost, calcMode);
            });
            
            const displayResults = (transactions, total, members, perPerson, calcMode) => {
                resultCard.innerHTML = '';
                const colorPalette = {
                    'blue-100': '#DBEAFE',
                    'green-100': '#D1FAE5',
                    'yellow-100': '#FEF3C7',
                    'purple-100': '#E9D5FF',
                    'pink-100': '#FCE7F3',
                    'red-100': '#FEE2E2',
                    'indigo-100': '#E0E7FF'
                };
                const colorKeys = ['blue-100', 'yellow-100', 'green-100', 'pink-100', 'indigo-100', 'red-100', 'purple-100'];
                const colorMap = new Map();
                
                // (修正) 参加者ID -> 名前のマッピング
                const sortedParticipants = [...participants].sort((a, b) => a.name.localeCompare(b.name, 'ja'));
                sortedParticipants.forEach((p, index) => {
                    colorMap.set(p.id, colorPalette[colorKeys[index % colorKeys.length]]);
                });
                
                transactions.sort((a, b) => {
                    const nameA = getParticipantName(a.from);
                    const nameB = getParticipantName(b.from);
                    const rankA = nameA.startsWith('参加者') ? 1 : 0;
                    const rankB = nameB.startsWith('参加者') ? 1 : 0;
                    if (rankA !== rankB) return rankA - rankB;
                    return nameA.localeCompare(nameB, 'ja');
                });


                if (transactions.length === 0) {
                    resultCard.innerHTML = `<p class="text-center text-gray-600">精算の必要はありません。</p>`;
                } else {
                    transactions.forEach((t) => {
                        // (修正) IDから名前を取得
                        const fromName = getParticipantName(t.from);
                        const toName = getParticipantName(t.to);
                        const fromColor = colorMap.get(t.from) || '#F3F4F6';
                        const toColor = colorMap.get(t.to) || '#F3F4F6';
                        
                        const resultEl = document.createElement('div');
                        resultEl.className = `p-4 rounded-lg fade-in`;
                        resultEl.style.background = `linear-gradient(to right, ${fromColor} 0%, #FFFFFF 50%, ${toColor} 100%)`;

                        const mainInfo = `
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                    <!-- (修正) 文字サイズ font-bold -> font-medium text-sm -->
                                    <span class="font-medium text-sm text-gray-800">${fromName}</span>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-500"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                                    <!-- (修正) 文字サイズ font-bold -> font-medium text-sm -->
                                    <span class="font-medium text-sm text-gray-800">${toName}</span>
                                </div>
                                <!-- (修正) 文字サイズ text-lg -> text-base -->
                                <span class="font-bold text-base text-indigo-700">¥${t.amount.toLocaleString()}</span>
                            </div>
                        `;

                        let paymentDetail = '';
                        if (calcMode === 'cash') {
                            const payment = getOptimalPayment(t.amount);
                            paymentDetail = `
                                <div class="mt-3 pt-3 border-t border-gray-400 border-opacity-30">
                                    <!-- (修正) 文字サイズ text-sm -> text-xs -->
                                    <p class="text-xs font-medium text-gray-800">支払い方法提案:</p>
                                    <!-- (修正) 文字サイズ text-sm -> text-xs -->
                                    <p class="text-xs text-gray-600">${payment.text}</p>
                                </div>
                            `;
                        }

                        resultEl.innerHTML = mainInfo + paymentDetail;
                        resultCard.appendChild(resultEl);
                    });
                }
                
                summaryDiv.innerHTML = `
                    <strong>合計金額:</strong> ¥${total.toLocaleString()} / 
                    <strong>参加人数:</strong> ${members}人 / 
                    <strong>一人あたり(目安):</strong> 約¥${perPerson.toLocaleString()}
                `;

                resultContainer.classList.remove('hidden');
                resultContainer.scrollIntoView({ behavior: 'smooth' });
            };
            
            // --- PWA Registration ---
            if ('serviceWorker' in navigator) {
                // (修正) 外部ファイル sw.js を登録
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            }

            // --- Initial Load ---
            loadState();
        });
    </script>
</body>
</html>



